{"meta":{"title":"hsiliver个人博客","subtitle":"桃李不言，下自成蹊","description":"web前端 js基础 个人博客","author":"hsiliver","url":"http://www.hsiliver.space","root":"/"},"pages":[{"title":"categories","date":"2019-07-08T06:05:17.000Z","updated":"2019-07-08T06:05:52.587Z","comments":false,"path":"categories/index.html","permalink":"http://www.hsiliver.space/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-08T06:04:58.000Z","updated":"2019-07-08T06:31:48.344Z","comments":false,"path":"tags/index.html","permalink":"http://www.hsiliver.space/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"css2","slug":"css","date":"2019-07-09T04:10:58.000Z","updated":"2019-07-09T03:02:59.463Z","comments":true,"path":"2019/07/09/css/","link":"","permalink":"http://www.hsiliver.space/2019/07/09/css/","excerpt":"","text":"CSS层叠样式表(cascating style sheet)选择器选择器类型 权重 important infinity 行间样式 1000 id 100 class|属性|伪类 10 标签|伪元素 1 通配符 0 父子选择器 div span 直接子元素选择器 div&gt;span 并列选择器 div.demo 分组选择器 div, span{} margin: 0 auto; 自适应 background-color:背景颜色 background-repeat: no repeat / repeat-x / repeat-y; 背景重复 不重复 x方向重复 y方向重复 background-size:也可以是百分比 cover 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 contain 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 background-position : x y ;——背景图片的定位 x-x方向 y-y方向 border:外部框 12345// 三角形制作div&#123; border: 35px solid transparent; border-left: 35px solid &#125; outline: 外部轮廓线 font-size: 文字高度（默认16px） 1em = 1font-size line-height: 单行文本高度 text-indent: x em; 缩进x文本的单位 text-decoration: line-throng / none / underline / overline; 中划线 无 下划线 上划线 font-family: arial;( 字体种类 ) font-style: italic / oblique / normal; 字体样式 斜体 倾斜 标准（前面两个差不多） text-align : center; //文本居中 vertical-align: middle; //文本类对齐线 一旦文本类或者文本类块级元素内有字了，设置了vertical-align: middle; 的文字就会相对那个元素内的字体对齐 单行文本高度 = 容器高度——普遍的居中方式 cursor: pointer; // 鼠标在某元素上锁呈现的样式为小手 小知识补充 rgb（0， 0， 0） 分别代表red， green， blue rgba（0， 0， 0， 0.5） 分别代表red， green， blue， 透明度 box-shadow: 5px 5px 5px rgba(0, 0, 0, 0.3); 盒模型= margin + padding + border + element / content 块级元素 : div p ul li ol form（独占一行，可以通过css改变宽高） 行级元素 : span strong em a del（内容决定元素所占位置，不可通过css改变宽高） 行级块元素 : img（两者优点的结合） padding : 上 右 下 左； : 上 左右 下 : 上下 左右 left / top / right / bottom / z-index——只适用于有定位的元素 position:absolute / relative / fixed; 定位 absolute——脱离原来位置相对于有定位的父级定位，没有则相对于窗口定位 relative——相对于自身初始位置定位 fixed—— 相对于窗口定位 编程思想——先写html / 先写css 行级元素只能嵌套行级元素，块级元素可以嵌套任何元素关于margin塌陷问题垂直之间塌陷的原则是以两盒子最大的外边距为准 解决办法: 触发盒子的bfc position: absolute; display: inline-block; float: left / right; overflow: hidden; (原理: 改变渲染规则) 关于浮动流: 文本以及文本类块级元素可以看到浮动流 清除浮动 : 利用伪元素、 12345span::after&#123; content: \"\";/*——让伪元素生效*/ clear: both;/*——清除浮动*/ display: block;/*——让clear生效*/&#125; 凡是设置了position和float，元素会自动变成inline-block 伪元素: ::after ::before 单行文本溢出打点: 12345div&#123; white-space: nowrap; overflow-hidden; text-overflow: ellipsis;&#125; 淘宝logo制作方法 12345div&#123; width: 0; padding-top: 90px; overflow: hidden;&#125; 标准盒模型变IE盒模型 123div&#123; box-sizing: border-box;&#125; 描述一下盒模型margin：设置一个元素所有外边距的宽度 border： 围绕元素内容和内边距的一条或多条线 padding： 属性定义元素的内边距。padding 属性接受长度值或百分比值，但不允许使用负值 content：内容区 W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分。 IE 盒子模型的 content 部分包含了 border 和 pading 简述display常用的的属性 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值） list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 flex 此元素将作为css3弹性盒模型 CSS3可用的伪类有哪些？ :first-child选择某个元素的第一个子元素； :last-child选择某个元素的最后一个子元素； :nth-child()选择某个元素的一个或多个特定的子元素； :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type()选择指定的元素； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个了元素； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty选择的元素里面没有任何内容。 position有哪些值， 有什么区别？ 值 描述 absolute 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。 fixed 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 inherit 规定应该从父元素继承 position 属性的值。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"css","slug":"css","permalink":"http://www.hsiliver.space/tags/css/"},{"name":"css2","slug":"css2","permalink":"http://www.hsiliver.space/tags/css2/"}]},{"title":"细说meta标签","slug":"meta","date":"2019-07-09T04:06:58.000Z","updated":"2019-07-09T03:00:46.858Z","comments":true,"path":"2019/07/09/meta/","link":"","permalink":"http://www.hsiliver.space/2019/07/09/meta/","excerpt":"","text":"细说meta标签12&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。 12&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\"&gt;以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面。 12&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\"&gt;以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面。 123456&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge, chrome=1&quot;&gt;以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1将允许站点在使用了谷歌浏览器内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。目前绝大多数网站都用&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=EmulateIE7&quot;&gt;来作为IE8的兼容方法。为了避免制作出的页面在IE8下面出现错误 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; device-width：设备宽度device-height：设备高度width: 视口的宽度hieght: 视口的高度user-scalable：是否允许用户缩放yes / noinitial-scale：页面初始缩放值（可以带小数）minimum-scale：页面最小缩放比（可以带小数）maximum-scale：页面最大缩放比（可以带小数） 有时大家会见到同时写了不允许缩放，又写了最小缩放比，那这不是冲突了？为什么都已经写了不允许缩放还有写那些？ 有一些第三方工具能够破坏user-scalable, 比方说一些给父母的手机把蚊子放大的工具，就会有可能，不过一般没可能 像iPhone5下会有黑边 所以写全了，可以避免一些bug ios10不支持user-scalable=noinitial-scaleble有值的情况下算页面的公式缩放比 = css像素 / viewport宽度 12&lt;meta name=\"format-detection\" content=\"telephone=no, email=no\"&gt;禁止识别电话与邮箱(但是邮箱没效果) 12&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt;添加到主屏后的标题(ios) 12&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\"&gt;添加到主屏后, 全屏显示, 删除苹果默认的工具栏和菜单栏(无用) 12&lt;link rel=\"app-touch-icon-precomposed\" href=\"./demo/lihong.jpg\"&gt;放在桌面上的logo 12&lt;link rel=\"app-touch-startup-img\" href=\"./demo/lihong.jpg\"&gt;启动时的动画(无用) 12&lt;meta name=\"x5-orientation\" content=\"portrait\"&gt;设置x5内核浏览器只能竖屏浏览 (只有UC有效) 12&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;设置x5内核浏览器全屏浏览 12&lt;meta name=\"screen-orientation\" content=\"portrait\"&gt;设置UC浏览器只能竖屏浏览 12&lt;meta name=\"full-screen\" content=\"yes\"&gt;设置UC浏览器全屏浏览","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"html5","slug":"html5","permalink":"http://www.hsiliver.space/tags/html5/"},{"name":"meta标签","slug":"meta标签","permalink":"http://www.hsiliver.space/tags/meta标签/"},{"name":"混合app","slug":"混合app","permalink":"http://www.hsiliver.space/tags/混合app/"}]},{"title":"html总述","slug":"html","date":"2019-07-09T04:03:58.000Z","updated":"2019-07-09T02:59:19.178Z","comments":true,"path":"2019/07/09/html/","link":"","permalink":"http://www.hsiliver.space/2019/07/09/html/","excerpt":"","text":"html4的以及html5 的一些新增初始标签12345&lt;!DOCTYPE html&gt; &lt;!-- 声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式 --&gt;&lt;!-- document.compatMode： BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。 CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。--&gt; 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat, 这也就是恶魔的开始————浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。（向后兼容） 如果你的页面添加了那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。​ 这就是的作用 –&gt; 1&lt;html lang=\"en\"&gt; 向搜索引擎表示该页面是html语言，并且语言为英文网站，其”lang”的意思就是language，语言的意思， 而“en”即表示english，当然你也可以写zh——代表中文，不过建议还是写en，毕竟这个主要是给搜索引擎看的， 搜索引擎不会去判断该站点是中文站还是英文站，所以这句话就是让搜索引擎知道，你的站点是中文站，对html页面本身不会有影响 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;!--这是被&lt;html&gt;包含的头文件头--&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;!-- 如果你的网页里面出现了中文，在头部没有这一句 的话，将会导致中文乱码。 因此这是编码格式，告诉给浏览器用什么方式来读这页代码。 --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0 user-scalable=no\"&gt; &lt;!-- name=\"viewport\"—— 视口 content=\"width=device-width —— 设备宽度（针对安卓） window Phone IE浏览器，上横竖屏的宽度 = 竖屏宽度 initial-scale=1.0 —— 缩放比例（针对iPhone/iPad）iPhone/iPad ，上横竖屏的宽度 = 竖屏宽度 （因为兼容性的问题要写两个） user-scalable=no —— 不允许用户放大 作用：将页面大小根据分辨率不同进行相应的调节，减少手机端跟PC端上图像呈现的差异 --&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;!-- &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=7\"&gt; #以上代码告诉IE浏览器，无论是否用DTD声明文档标准，IE8/9都会以IE7引擎来渲染页面。 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=8\"&gt; #以上代码告诉IE浏览器，IE8/9都会以IE8引擎来渲染页面。 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; #以上代码告诉IE浏览器，IE8/9及以后的版本都会以最高版本IE来渲染页面。 &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge,chrome=1\"&gt; #以上代码IE=edge告诉IE使用最新的引擎渲染网页，chrome=1将允许站点在使用了谷歌浏览器 内嵌框架（Chrome Frame）的客户端渲染，对于没有使用的，则没有任何影响。 目前绝大多数网站都用&lt;meta http-equiv=”X-UA-Compatible” content=”IE=EmulateIE7″ &gt; 来作为IE8的兼容方法。为了避免制作出的页面在IE8下面出现错误。 --&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 这是网站的名字 --&gt; &lt;link rel=\"stylesheet\" href=\"../css/index.css\"&gt; &lt;!-- 外部引入css文件 ， 如果需要在内部写的话，直接&lt;style&gt;写在里面即可&lt;/style&gt;--&gt;&lt;/head&gt; &lt;!-- head代表头部，那肯定是一些重要的预备工作，那么真正的编写 html 就在body标签里面了， body顾名思义 —— 身体，代表着控制一个人的神经系统，那么在html中也是如此--&gt; 12345678&lt;body&gt; &lt;!-- &lt;div class=\"wrapper\"&gt;hello&lt;/div&gt; --&gt; &lt;img src=\"../image/lin.jpg\" alt=\"\"&gt; &lt;script src=\"../js/index.js\"&gt;&lt;/script&gt; &lt;!-- script标签是可以引入外部标签的 —— 通过 src=“” 引入 如果在内部写的话，直接&lt;script&gt;编写在此处即可&lt;/script&gt;--&gt;&lt;/body&gt;&lt;/html&gt; Html内容标签以及应用html —— hyperText markup language 超文本 标记 语言 &amp;nbsp —— 空格 &amp;lt (less than) —— 小于 &amp;gt （great than）—— 大于 &lt;br&gt;——回车（单标签） &lt;hr&gt;—— 单横线（单标签） &lt;meta&gt;——（单标签） &lt;link&gt; ——引入标签（单标签） SEO搜索引擎优化技术 1&lt;meta content=\"\" name=\"keywords\"&gt; //关键字 1&lt;meta content=\"\" name=\"description\"&gt; //描述 有序列表 123456789101112131415&lt;ol reversed=\"reversed\"&gt; // 倒着排序 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;ol start=\"2\"&gt; // 从第二开始排序 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; &lt;ol type=\"a/A/1/I/i\"&gt; // 按照不同的顺序来排 &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 无序列表 123456 &lt;ul type=\"disc\"&gt; // 默认实心圆 还有circle（圈）square（方块） &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;img src=\"\" alt=\"\" title=\"\"&gt; // ——图片标签（单标签） src——图片地址 alt——图片占位符（当图片报错是展示的文字） title——图片提示符 超文本&lt;a href=&quot;&quot;&gt;&lt;/a&gt;1.&lt;a href=&quot;&quot; target=&quot;_black&quot;&gt;&lt;/a&gt; herf——链接地址 target=”_black”——一个属性表示新的页面打开 2.锚点 &lt;a href=&quot;#demo&quot;&gt;&lt;/a&gt;——寻找并跳转到ID为demo的位置 3.打电话和发邮件 12&lt;a href=\"tel：159xxxx3725\"&gt;&lt;/a&gt;&lt;a href=\"mailto：8265xxxx4@qq.com\"&gt;&lt;/a&gt; 4.协议限定符（运行javascript代码） 12&lt;a href=\"javascript:void(false);\"&gt;&lt;/a&gt;&lt;a href=\"javascript:alert('a');\"&gt;&lt;/a&gt; 新闻标题（已经设置好css的文字格式） 12345&lt;h1&gt;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;h3&gt;&lt;/h3&gt;&lt;h4&gt;&lt;/h4&gt;&lt;h5&gt;&lt;/h5&gt; 各种字体标签 123456&lt;em&gt;50&lt;/em&gt;&lt;span&gt;50&lt;/span&gt;&lt;del&gt;50&lt;/del&gt;&lt;address&gt;50&lt;/address&gt;&lt;strong&gt;50&lt;/strong&gt;&lt;p&gt;50&lt;/p&gt; 在浏览器中就是这样了 505050 50 50 50 form表单 最基础的用户名密码输入框： 123456789&lt;form method=\"get\" action=\"\"&gt; &lt;p&gt; username:&lt;input type=\"text\" name=\"uesrname\" value=\"请输入用户名\"&gt; &lt;/p&gt; &lt;p&gt; password:&lt;input type=\"password\" name=\"password\"&gt; &lt;/p&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; 单选题type=&quot;radio&quot; 多选题type=&quot;checkbox&quot; 1234567&lt;form method=\"get\" action=\"\"&gt; &lt;p&gt;你最喜欢的水果是（ ）？&lt;/p&gt; A. 橘子&lt;input type=\"radio\" name=\"最喜欢的水果\" value=\"oringe\" checked=\"checked\"&gt; // 默认选中 b. 苹果&lt;input type=\"radio\" name=\"最喜欢的水果\" value=\"apple\"&gt; c. 香蕉&lt;input type=\"radio\" name=\"最喜欢的水果\" value=\"banana\"&gt; &lt;input type=\"submit\"&gt; //提交按钮 &lt;/form&gt; name——为了使他们变成同一道题 下拉菜单选项 12345678&lt;form method=\"get\" action=\"\"&gt; &lt;select name=\"guojia\" id=\"position\"&gt; &lt;option value=\"China\"&gt;中国&lt;/option&gt; &lt;option value=\"amrician\"&gt;美国&lt;/option&gt; &lt;option value=\"japan\"&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; HTML与浏览器Doctype 作用？标准模式与兼容模式各有什么区别? DOCTYPE是用来声明文档类型和DTD规范的。声明位于HTML文档中的第一行，不是一个HTML标签，处于 html 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 标准模式的排版 和 JS 运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 在HTML4.01中&lt;!doctype&gt;声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容 HTML5不基于SGML，所以不用指定DTD HTML 全局属性 全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。 全局属性 | MDN canvas和svg的区别 canvas是html5提供的新元素，而svg存在的历史要比canvas久远，已经有十几年了。svg并不是html5专有的标签，最初svg是用xml技术（超文本扩展语言，可以自定义标签或属性）描述二维图形的语言。在H5中看似canvas与svg很像，但是，他们有巨大的差别。 首先，从它们的功能上来讲，canvas可以看做是一个画布。，其绘制出来的图形为标量图，因此，可以在canvas中引入jpg或png这类格式的图片，在实际开发中，大型的网络游戏都是用canvas画布做出来的，并且canvas的技术现在已经相当的成熟。另外，我们喜欢用canvas来做一些统计用的图表，如柱状图曲线图或饼状图等。 而svg，所绘制的图形为矢量图，所以其用法上受到了限制。因为只能绘制矢量图，所以svg中不能引入普通的图片，因为矢量图的不会失真的效果，在项目中我们会用来做小图标。但是由于其本质为矢量图，可以被无限放大而不会失真，这很适合被用来做地图，而百度地图就是用svg技术做出来的。 另外从技术发面来讲canvas里面绘制的图形不能被引擎抓取，如我们要让canvas里面的一个图片跟随鼠标事件: canvas.onmouseover=function(){}。 而svg里面的图形可以被引擎抓取，支持事件的绑定。另外canvas中我们绘制图形通常是通过javascript来实现，svg更多的是通过标签来来实现，如在svg中绘制正矩形形就要用，这里我们不能用属性style=”width:XXX;height:XXX;”来定义。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 定义：CSS 规范规定，每个元素都有 display 属性，确定该元素的类型，每个元素都有默认的 display 值，如 div 的 display 默认值为“block”，则为“块级”元素；span 默认 display 属性值为“inline”，是“行内”元素。 行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 空元素： 常见: br hr img input link meta 不常见: area base col command embed keygen param source track wbr 不同浏览器（版本）、HTML4（5）、CSS2 等实际略有差异 参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements 页面导入样式时，使用 link 和@import 有什么区别？ link 属于 XHTML 标签，除了加载 CSS 外，还能用于定义 RSS, 定义 rel 连接属性等作用；而@import 是 CSS 提供的，只能用于加载 CSS; 页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载; import 是 CSS2.1 提出的，只在 IE5 以上才能被识别，而 link 是 XHTML 标签，无兼容问题; link 支持使用 js 控制 DOM 去改变样式，而@import 不支持; 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer 或 Rendering Engine)和 JS 引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后渲染到用户的屏幕上。 JS 引擎则：解析和执行 javascript 来实现逻辑和控制 DOM 进行交互。 最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。 HTML5变化 新的语义化元素 header footer nav main article section 删除了一些纯样式的标签 表单增强 新API 离线 （applicationCache ） 音视频 （audio, vidio） 图形 （canvans） 实时通信（websoket） 本地存储（localStorage, indexDB） 设备能力（地图定位，手机摇一摇） em 与 i 的区别 效果都是斜体 em 是语义化标签，表强调 i 是样式标签， 表斜体 哪些元素可以自闭合？ 表单元素 input img br, hr meta, link HTML和DOM的关系 HTML只是一个字符串 DOM由HTML解析而来 JS可以维护DOM property和attribute的区别 例如一个input标签 1&lt;input value=\"3\" /&gt; 他的attribute是3 但如果使用input.value = 4, 或 直接修改值为4，这时再去getAttribute得到的还是”3” property 和 attribute非常容易混淆，两个单词的中文翻译也都非常相近（property：属性，attribute：特性），但实际上，二者是不同的东西，属于不同的范畴。 property是DOM中的属性，是JavaScript里的对象； attribute是HTML标签上的特性，它的值只能够是字符串； form 作用 直接提交表单 使用submit / reset按钮 便于浏览器保存表单 第三方库可以整体取值 第三方库可以进行表单验证 主流浏览器机器内核 浏览器 内核 备注 IE Trident IE、猎豹安全、360 极速浏览器、百度浏览器 firefox Gecko Safari webkit 从 Safari 推出之时起，它的渲染引擎就是 Webkit，一提到 webkit，首先想到的便是 chrome，Webkit 的鼻祖其实是 Safari。 chrome Chromium/Blink 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核。二次开发 Opera blink Opera内核原为：Presto，现在跟随 chrome 用 blink 内核。 简述一下你对 HTML 语义化的理解？ 用正确的标签做正确的事情。 html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密） cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie 数据大小不能超过 4k。 sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 有效期（生命周期）： localStorage: 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage: 数据在当前浏览器窗口关闭后自动删除。 cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 共享 sessionStorage不能共享，localStorage在同源文档之间共享，cookie在同源且符合path规则的文档之间共享 html 中 title 属性和 alt 属性的区别？1&lt;img src=\"#\" alt=\"alt信息\" /&gt; 当图片不输出信息的时候，会显示 alt 信息 鼠标放上去没有信息，当图片正常读取，不会出现 alt 信息。 1&lt;img src=\"#\" alt=\"alt信息\" title=\"title信息\" /&gt; 当图片不输出信息的时候，会显示 alt 信息 鼠标放上去会出现 title 信息； 当图片正常输出的时候，不会出现 alt 信息，鼠标放上去会出现 title 信息。 除了纯装饰图片外都必须设置有意义的值，搜索引擎会分析。 另外还有一些关于 title 属性的知识： title 属性可以用在除了 base，basefont，head，html，meta，param，script 和 title 之外的所有标签。 title 属性的功能是提示。额外的说明信息和非本质的信息请使用 title 属性。title 属性值可以比 alt 属性值设置的更长。 title 属性有一个很好的用途，即为链接添加描述性文字，特别是当连接本身并不是十分清楚的表达了链接的目的。 为什么我们要弃用table标签？ table的缺点在于服务器把代码加载到本地服务器的过程中，本来是加载一行执行一行，但是table标签是里面的东西全都下载完之后才会显示出来，那么 如果图片很多的话 就会导致网页一直加载不出来，除非所有的图片和内容都加载完。如果要等到所有的图片全都加载完之后才显示出来的话那也太慢了，所以table标签现在我们基本放弃使用了。 head 元素 head子元素大概分为三类，分别是： 描述网页基本信息的 指向渲染网页需要其他文件链接的 各大厂商根据自己需要定制的 网页基本信息 一个网页，首先得有个标题，就跟人有名字一样。除此之外，还可以根据实际需要补充一些基本信息。 文档标题（浏览器标签中显示的文本）：深入了解 head 元素 编码格式： 如果你的页面出现乱码，那一般就是编码格式不对 视窗设置： 搜索引擎优化相关内容： IE浏览器版本渲染设置： 其他文件链接 CSS 文件： JavaScript 文件： 1&lt;script src=“script.js\"&gt;&lt;/script&gt; 但是为了让页面的样子更早的让用户看到，一般把JS文件放到body的底部 同样分享页面到QQ的聊天窗口，有些页面直接就是一个链接，但是有些页面有标题，图片，还有文字介绍。为什么区别这么明显呢？其实就是看有没有设置下面这三个内容 123&lt;meta itemprop=\"name\" content=\"这是分享的标题\"/&gt;&lt;meta itemprop=\"image\" content=\"http://imgcache.qq.com/qqshow/ac/v4/global/logo.png\" /&gt;&lt;meta name=\"description\" itemprop=\"description\" content=\"这是要分享的内容\" /&gt; 移动端项目需要注意的4个问题 meta中设置viewport 阻止用户手滑放大或缩小页面，需要在 index.html中添加meta元素,设置viewport。 123&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"&gt;这其实就算是很标准的一个meta标签了下一篇会细说meta标签的用处 CSS样式统一问题 我们需要重置页面样式，因为在不同的手机浏览器上，默认的css样式不是统一的。 解决方法：使用reset.css重置所有元素的默认样式 一像素边框问题 有的手机分辨率比较高，是2倍屏或3倍屏，手机上的浏览器就会把CSS中的1像素值展示为2个或3个物理宽度 解决方法： 添加一个border.css库，将利用scroll缩放的原理将边框重置。当我们需要使用一像素边框时只需要在标签上添加对应类名，如设置底部一像素边框就在标签上加入”border-bottom”的class名 300毫秒点击延迟问题 在移动端开发中，某些机型上使用click事件会延迟300ms才执行，这样影响了用户体验。 解决方法： 引入fastclick.js。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"html5","slug":"html5","permalink":"http://www.hsiliver.space/tags/html5/"}]},{"title":"VUE-Router","slug":"vue-router","date":"2019-07-08T14:56:58.000Z","updated":"2019-07-09T02:55:33.830Z","comments":true,"path":"2019/07/08/vue-router/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/vue-router/","excerpt":"","text":"vue-router为我们创建单页面应用提供环境 等我想好怎么说再更新，这个比较复杂，但不难，就是难解释清除","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"VUE-router","slug":"VUE-router","permalink":"http://www.hsiliver.space/tags/VUE-router/"}]},{"title":"VUE组件","slug":"vue-组件","date":"2019-07-08T14:54:58.000Z","updated":"2019-07-09T02:52:23.494Z","comments":true,"path":"2019/07/08/vue-组件/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/vue-组件/","excerpt":"","text":"vue-组件定义：已经写好的，供我们修改使用，这些具备复用性高，易于修改、维护。比如 element 滴滴开源组件库 全局定义一个组件 / 指令 一定要写在一个Vue实例下 注意：这是一个html模板需要遵循html的规则，比如：span 标签不能嵌套 div， 但是字符串模板不一样，写成什么呀就是什么样 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;div id=\"demo\"&gt; &lt;my-component name=\"hsz\" num=\"num\"&gt;&lt;/my-component&gt; &lt;!-- 用户层可以通过操作name属性改变自己的昵称 相当于一个封闭的作用域 但是要注意避免直接操作name值, 例如操作num那样间接改变 --&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; // 参数：组件名, 组件设置 Vue.component(\"my-component\", &#123; template: `&lt;div&gt; &lt;p&gt;我是一个组件&lt;/p&gt; &lt;button @click=\"count++\"&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;/div&gt;`, data : function () &#123; // 这里的data属性规定必须是个函数 return &#123; count : this.num &#125; &#125;, props : &#123; // 这里的属性相当于我们提供的接口 name : &#123; type : String, // 权限设置 String require : true // 必须填写 &#125;, num : &#123; type : Number, default : 0 &#125; &#125; &#125;) Vue.directive(\"focus\", &#123; update() &#123; console.log(333); &#125; &#125;) new Vue(&#123; el : \"#demo\", // Vue实例 &#125;)&lt;/script&gt; 局部组件 / 指令 12345678910111213141516171819202122&lt;div id=\"demo\"&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; new Vue(&#123; el : \"#demo\", // Vue实例 components : &#123; \"hsz\" : &#123; template : `&lt;div&gt;我是一个局部组件,只在#demo好使&lt;/div&gt;` &#125; &#125;, directives : &#123; focus : &#123; update() &#123; console.log(123); &#125; &#125; &#125; &#125;)&lt;/script&gt; 自定义事件——类似 jQuery的 trigger 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;body&gt; &lt;div class=\"demo\"&gt; &#123;&#123;total&#125;&#125; &lt;hsz @add_total=\"add\"&gt;&lt;/hsz&gt; &lt;hsz @add_total=\"add\"&gt;&lt;/hsz&gt; &lt;/div&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt; &lt;script&gt; Vue.component(\"hsz\", &#123; // 点击一次执行一次 addCount 函数， // 同时触发绑定的自定义事件 add_total template : ` &lt;div&gt; &lt;button @click=\"addCount\"&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt; &lt;/div&gt; `, data() &#123; return &#123; count : 0 &#125; &#125;, methods : &#123; addCount() &#123; this.count ++; // 自定义事件 this.$emit(\"add_total\") // 执行自定义事件 &#125; &#125; &#125;) // 功能 点击按钮 就加1 new Vue(&#123; el : \".demo\", data : &#123; total : 0 &#125;, methods : &#123; add () &#123; this.total ++; &#125; &#125; &#125;) // 功能 获取总和 &lt;/script&gt;&lt;/body&gt; element组件示例element组件示例代码","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"VUE-组件","slug":"VUE-组件","permalink":"http://www.hsiliver.space/tags/VUE-组件/"}]},{"title":"VUE-cli","slug":"vue-cli","date":"2019-07-08T14:44:58.000Z","updated":"2019-07-09T02:56:08.855Z","comments":true,"path":"2019/07/08/vue-cli/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/vue-cli/","excerpt":"","text":"Vue-cli(构建工具——脚手架)内部模板有已经给我们配置好了wepack的模板 命令 12npm install vue-cli -g下载到全局 12vue -V查看版本 1234vue init &lt;template&gt; &lt;project-name&gt;&lt;项目模板&gt;&lt;项目名字&gt;vue init webpack myVue 通常我们用官方的webpack模板 123456789101112\"scripts\": &#123; \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\", \"start\": \"npm run dev\", \"build\": \"node build/build.js\" &#125;/*这里我们配置的时候没有使用ESlintvue run dev == 执行dev脚本（开发环境下）vue run build(开发完的环境下)*/ 12345\"dependencies\": &#123; \"vue\": \"^2.5.2\", \"vue-router\": \"^3.0.1\" &#125;// 运行时所需要的包 1234567891011121314151617181920212223242526272829303132333435363738\"devDependencies\": &#123; \"autoprefixer\": \"^7.1.2\", \"babel-core\": \"^6.22.1\", \"babel-helper-vue-jsx-merge-props\": \"^2.0.3\", \"babel-loader\": \"^7.1.1\", \"babel-plugin-syntax-jsx\": \"^6.18.0\", \"babel-plugin-transform-runtime\": \"^6.22.0\", \"babel-plugin-transform-vue-jsx\": \"^3.5.0\", \"babel-preset-env\": \"^1.3.2\", \"babel-preset-stage-2\": \"^6.22.0\", \"chalk\": \"^2.0.1\", \"copy-webpack-plugin\": \"^4.0.1\", \"css-loader\": \"^0.28.0\", \"extract-text-webpack-plugin\": \"^3.0.0\", \"file-loader\": \"^1.1.4\", \"friendly-errors-webpack-plugin\": \"^1.6.1\", \"html-webpack-plugin\": \"^2.30.1\", \"node-notifier\": \"^5.1.2\", \"optimize-css-assets-webpack-plugin\": \"^3.2.0\", \"ora\": \"^1.2.0\", \"portfinder\": \"^1.0.13\", \"postcss-import\": \"^11.0.0\", \"postcss-loader\": \"^2.0.8\", \"postcss-url\": \"^7.2.1\", \"rimraf\": \"^2.6.0\", \"semver\": \"^5.3.0\", \"shelljs\": \"^0.7.6\", \"uglifyjs-webpack-plugin\": \"^1.1.1\", \"url-loader\": \"^0.5.8\", \"vue-loader\": \"^13.3.0\", \"vue-style-loader\": \"^3.0.1\", \"vue-template-compiler\": \"^2.5.2\", \"webpack\": \"^3.6.0\", \"webpack-bundle-analyzer\": \"^2.9.0\", \"webpack-dev-server\": \"^2.9.1\", \"webpack-merge\": \"^4.1.0\" &#125;// 开发时所需要的包 12345\"engines\": &#123; \"node\": \"&gt;= 6.0.0\", \"npm\": \"&gt;= 3.0.0\" &#125;// 整个项目需要用到的引擎 123456&quot;browserslist&quot;: [ &quot;&gt; 1%&quot;, // 市场份额 &gt; 1% &quot;last 2 versions&quot;, // 最近的两个版本好使 &quot;not ie &lt;= 8&quot; // ie不 &lt;= 8 ]// 浏览器的配置 .babelrc文件(配置es6转es5的一些babel-loader)123456789&quot;presets&quot;: [ // 预设 // env——支持es5-7 [&quot;env&quot;, &#123; &quot;modules&quot;: false, // 模块化 &quot;targets&quot;: &#123; &quot;browsers&quot;: [&quot;&gt; 1%&quot;, &quot;last 2 versions&quot;, &quot;not ie &lt;= 8&quot;] &#125;, &quot;stage-2&quot; // 可使用草案2阶段的语法 &#125;] .editorconfig(编辑器配置)123456789root = true[*]charset = utf-8indent_style = spaceindent_size = 2end_of_line = lfinsert_final_newline = truetrim_trailing_whitespace = true .eslintignore1234// 如果我们配置了build/*.jsconfig/*.js// ESlint忽略build和config下的js文件检测 .eslintrc.js(ESlint配置) .gitignore(上传git时要忽略的文件配置) 1234567891011121314.DS_Storenode_modules//dist/npm-debug.log*yarn-debug.log*yarn-error.log*# Editor directories and files.idea.vscode*.suo*.ntvs**.njsproj*.sln src 下的 main.js 1234567891011121314151617181920import Vue from 'vue' // 引入vueimport App from './App' // 引入当前文件夹下的App.vue(自动识别.vue)// 这里将匿名导出(export default)的对象命名为App, 这样就引入了App组件// .vue文件会被vue-loader转换文.html文件, index.js已经帮我们配置好了路由import router from './router' // 路由 —— 引入当前目录下的router下的index.js(自动识别index.js)// 将这个匿名导出的路由命名为router// 在build文件夹下的webpack.base.conf.js文件内部有详细说明Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el : '#app', router : router, // 注册一个叫router的路由, 将上面的router注入 components : &#123; App &#125;, // &#123; App : App &#125; // 注册了一个局部组件，注入到App里面, 然后放到template模板里面进行覆盖 template: '&lt;App/&gt;'&#125;) 123456789&lt;template&gt; &lt;div id=&quot;app&quot;&gt; 我是App组件&#123;&#123;msg&#125;&#125; &lt;router-view/&gt; &lt;!-- 这个&lt;router-view/&gt;就会被替换掉，如下面src/router/index.js中代码所述 --&gt; &lt;/div&gt;&lt;/template&gt; 123456789export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 在App.vue文件中就是我们熟悉的 vue语法了 后续更新中&gt;&gt;&gt;&gt;&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"VUE.js","slug":"VUE-js","permalink":"http://www.hsiliver.space/tags/VUE-js/"},{"name":"vue-cli","slug":"vue-cli","permalink":"http://www.hsiliver.space/tags/vue-cli/"}]},{"title":"VUE声明式渲染","slug":"vue-process","date":"2019-07-08T14:34:58.000Z","updated":"2019-07-09T02:50:42.368Z","comments":true,"path":"2019/07/08/vue-process/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/vue-process/","excerpt":"","text":"声明式渲染 命令式编程 命令“机器”如何去做事情（how），这样不管你想要的是什么（what），它都会按照你的命令实现 1234var arr = [1, 2, 3];for (var i = 0; i &lt; 3; i ++) &#123; console.log(arr[i]);&#125; 声明式编程 高数“机器”你想要的是什么（what），让机器想如何去做（how）。 123arr.forEach(function (item) &#123; console.log(item);&#125;) vue就是典型的声明式编程 模板 html模板 123456789101112131415161718&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;div v-bind:class = \"&#123;box:cla&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", data : &#123; message : '&lt;div&gt;hellow world&#123;&#123;cla&#125;&#125;&lt;/div&gt;', // 仅仅只能解析字符串 // 如果我们要插入dom节点的话 // 必须要通过 v-html cla : true &#125;, &#125;)&lt;/script&gt; 字符串模板 12345678910111213141516171819&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;div v-bind:class = \"&#123;box:cla&#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-html=\"message\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script type=\"x/template\" id=\"template1\"&gt;&lt;div&gt;hellow world&#123;&#123;cla&#125;&#125;&lt;/div&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", data : &#123; message : '&lt;div&gt;hellow world&#123;&#123;cla&#125;&#125;&lt;/div&gt;', cla : true &#125;, template : \"#template1\" // 会替换掉我们上面所创建的 #demo // template: \"#template1\" &#125;)&lt;/script&gt; render 函数 123456789101112131415161718192021222324252627282930313233343536&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;div v-bind:class = \"&#123;box:cla&#125;\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"x/template\" id=\"template1\"&gt;&lt;div&gt;hellow world&#123;&#123;cla&#125;&#125;&lt;/div&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", data : &#123; message : '&lt;div&gt;hellow world&lt;/div&gt;', cla : true &#125;, // 使用render函数的时候就不可以在像以前一样使用： v-for等属性；但是有其他的解决方法 // 最接近底层的模板，会更加高效， // 但是没有 html模板 方便 // 一般写高效组件的时候才用render方法 render(createElement) &#123; var dom = createElement(\"div\", &#123; attrs: &#123; id: \"box\" &#125;, class: &#123; vue1: true, vue2: false &#125;, // domProps 优先级最高，会覆盖上面的 // domProps: &#123; // innerHTML: \"&lt;div&gt;html&lt;/div&gt;\" // &#125; // 接下来的子元素将会被完全覆盖 &#125;, [\"hellow\", createElement(\"p\", [\"world\"])]) return dom;// 渲染到页面 &#125; &#125;)&lt;/script&gt; 简单vue示例","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"VUE.js","slug":"VUE-js","permalink":"http://www.hsiliver.space/tags/VUE-js/"}]},{"title":"VUE.js","slug":"vue-basic","date":"2019-07-08T14:33:58.000Z","updated":"2019-07-09T02:47:20.947Z","comments":true,"path":"2019/07/08/vue-basic/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/vue-basic/","excerpt":"","text":"Vue.js官方文档：https://vuejs.org/ 中文官方文档：https://cn.vuejs.org/ vue是借鉴了Angularjs和reactjs的一些思想和优点的框架 渐进式框架——根据需求来实现功能 VUE的两大核心 响应的数据绑定 当数据发生改变时，自动更新视图 利用Object.definedProperty中的getter/setter代理数据 1234567var obj = &#123;&#125;;obj.a = 1;Object.defineProperty(obj, \"b\", &#123; value : 10 writeable : false&#125;)console.log(obj.b); // 10 视图组件 UI页面映射组件树 组件可重用，可维护 虚拟DOM 提供一种方便的工具，是的开发效率得到保证 保证最小化的DOM操作，是的执行效率得到保证 模仿实现 h 函数 1234567891011121314151617181920212223242526272829303132333435363738394041function vEvement(tagName, prop, children) &#123; if (!(this instanceof vEvement)) &#123; return new vEvement(tagName, prop, children) &#125; if (Object.prototype.toString.call(prop) === \"[object Array]\") &#123; children = prop; prop = &#123;&#125; &#125; this.tagName = tagName; // 标签名 this.children = children; // 子节点 this.prop = prop; // dom节点的一些属性 var count = 0; // 记录虚拟DOM节点有多少个 this.children.forEach( function(child, index) &#123; if (child instanceof vEvement) &#123; count += child.count; &#125; count++ &#125;); this.count = count;&#125;vEvement.prototype.render = function () &#123; var el = document.createElement(this.tagName); var children = this.children; var prop = this.prop; for (var item in prop) &#123; var curProp = prop[item]; el.setAttribute(item, curProp); &#125; children.forEach(function (child, index) &#123; if (child instanceof vEvement) &#123; var childDom = child.render(); &#125;else &#123; var childDom = document.createTextNode(child) &#125; el.appendChild(childDom); &#125;) return el;&#125;var dom = vEvement(\"div\",&#123;class: \"demo\", id: \"demo1\"&#125;, [\"hello world\", vEvement(\"p\", &#123;class: \"demo2\"&#125;, [\"我是p标签\"])]);console.log(dom);console.log(dom.render()); MVVM模式M : model 数据模型 V : View 视图模板 vm : View-model视图模型（vue主要实现的地方） 当然vue并不是用了严格的mvvm模式，只是借鉴了它的一些思想 VUE的运用 cdn引入 生产环境 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt; 开发环境 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue\"&gt;&lt;/script&gt; npm install vue NPM下载到本地 基础演示：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;!-- 类似微信小程序，进行数据绑定 --&gt; &#123;&#123;changeName&#125;&#125; &lt;!-- 绑定id --&gt; &lt;span v-bind:id=\"id\"&gt;&#123;&#123;name&#125;&#125;&lt;/span&gt; &lt;!-- 动态绑定数据, 控制dom节点的显示和隐藏 --&gt; &lt;div :class=&#123;demo2:ifClass&#125; v-show=\"ifShow\" v-if=\"fShow\"&gt;&lt;/div&gt; &lt;!-- 列表渲染, 循环遍历 --&gt; &lt;p v-for=\"item in message\"&gt;&#123;&#123;item.title&#125;&#125;&lt;/p&gt; &lt;!-- 点击事件v-on:click，键盘事件(v-on:keyup...) --&gt; &lt;button v-on:click=\"click\"&gt;点击&lt;/button&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", // 确定Vue的作用范围——demo data : &#123; name : \"hsz\", id : \"demo1\", ifClass : true, ifShow : true, fShow : false, // 删除整个dom节点了 // 从性能上考虑的话v-show更加有优势 // 当然我们不频繁隐藏显示的话v-if会更适合 message : [&#123; title : 18 &#125;, &#123; title : 10 &#125;] &#125;, computed : &#123; // 计算属性 changeName : function () &#123; return this.name + 123 // 监听changeName &#125; &#125;, methods : &#123; // 处理函数的字段 click : function () &#123; console.log(123); &#125; &#125; &#125;)&lt;/script&gt; input事件12345678910111213141516171819202122232425&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;!-- 键盘事件(v-on:keyup...), .enter——回车才触发 --&gt; &lt;input :id=\"id\" type=\"text\" v-on:keyup.enter=\"keyup\"&gt;click&lt;/input&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", // 确定Vue的作用范围——demo data : &#123; id : \"demo1\", &#125;, computed : &#123; // 计算属性 &#125;, methods : &#123; // 处理函数的字段 keyup : function () &#123; console.log(123); &#125; &#125; &#125;)&lt;/script&gt; 双向数据绑定1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"demo\"&gt; &lt;!-- 表单处理，双向数据绑定 --&gt; &lt;input :id=\"id\" type=\"text\" v-model=\"value\" v-on:keyup=\"keyup\"&gt;click&lt;/input&gt; &lt;/div&gt;&lt;/body&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el : \"#demo\", // 确定Vue的作用范围——demo data : &#123; id : \"demo1\", value : 123 &#125;, computed : &#123; // 计算属性 &#125;, methods : &#123; // 处理函数的字段 keyup : function () &#123; console.log(this.value); &#125; &#125; &#125;)&lt;/script&gt; 生命周期图 VUE命令 vue --version 查看版本 vue init 快速生成VUE项目","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"VUE.js","slug":"VUE-js","permalink":"http://www.hsiliver.space/tags/VUE-js/"}]},{"title":"VIDEO","slug":"player","date":"2019-07-08T14:25:58.000Z","updated":"2019-07-09T02:36:21.640Z","comments":true,"path":"2019/07/08/player/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/player/","excerpt":"","text":"video代码演示","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"},{"name":"播放器","slug":"播放器","permalink":"http://www.hsiliver.space/tags/播放器/"},{"name":"video","slug":"video","permalink":"http://www.hsiliver.space/tags/video/"}]},{"title":"SVG","slug":"svg","date":"2019-07-08T14:25:58.000Z","updated":"2019-07-09T02:35:08.563Z","comments":true,"path":"2019/07/08/svg/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/svg/","excerpt":"","text":"SVGsvg：矢量图（放大不失真），适合大面积的贴图，通常动画少或者较简单，用标签和css作图 canvas：适用于小面积绘图，适合动画 直线12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; line &#123; stroke: black; stroke-width: 3px; stroke-opacity: 0.5; fill-opacity: 0.3; stroke-linecap: square; stroke-linejoin: round; /*这跟canvas的stroke功能相同*/ stroke-dasharray: 10px; stroke-dashoffset: 10px; /*虚线，虚线偏移量*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=\"500\" height=\"500\" style=\"border: 1px solid black\"&gt; &lt;line x1=\"100\" y1=\"100\" x2=\"200\" y2=\"100\"&gt;&lt;/line&gt; &lt;/svg&gt;&lt;/body&gt; 矩形123&lt;rect x=\"50\" y=\"50\" width=\"100\" height=\"100\" rx=\"10\" ry=\"10\"&gt;&lt;!-- 起始位置 大小 圆角（x, y方向） —— 这些可以闭合的标签默认自带填充--&gt;&lt;/rect&gt; 圆、椭圆12&lt;circle r=\"50\" cx=\"220\" cy=\"100\"&gt;&lt;/circle&gt;&lt;ellipse rx=\"100\" ry=\"50\" cx=\"400\" cy=\"150\"&gt;&lt;/ellipse&gt; 折线12&lt;polyline points=\"300 300, 400 50, 400 100, 500 50\" style=\"fill:transparent;stroke:red;\"&gt;&lt;/polyline&gt;&lt;!-- 直线，默认闭合填充,配合css取消填充 --&gt; 多边形、文字1234&lt;polygon points=\"300 300, 400 50, 400 100,500 50\"&gt;&lt;/polygon&gt;&lt;!-- 闭合多边形 --&gt;&lt;text x=\"405\" y=\"220\"&gt;hello,world&lt;/text&gt; path1234567&lt;path d=\"M 100 200 A 60 60 0 1 1 200 200\"&gt;&lt;/path&gt;&lt;!-- 起始点：x坐标 y坐标 圆弧：x半径 y半径 旋转角度 优(劣)弧 顺(逆)时针 圆心坐标--&gt;&lt;!-- 大写表示绝对位置，小写表示相对位置H 横向移动 V（一个参数）纵向移动 z（不分大小写）闭合区间L lineTo() A arcTo()--&gt; 渐变12345678&lt;defs&gt; &lt;linearGradient id=\"bg1\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color: rgb(255, 255, 0);\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color: rgb(25, 255, 2);\"/&gt; &lt;/linearGradient&gt; &lt;!-- 渐变必须写在defs里面 --&gt;&lt;/defs&gt;&lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" style=\"fill: url(#bg1)\"/&gt; 高斯模糊12345678910111213&lt;defs&gt; &lt;linearGradient id=\"bg1\" x1=\"0\" y1=\"0\" x2=\"0\" y2=\"100%\"&gt; &lt;stop offset=\"0%\" style=\"stop-color: rgb(255, 255, 0);\"/&gt; &lt;stop offset=\"100%\" style=\"stop-color: rgb(25, 255, 2);\"/&gt; &lt;/linearGradient&gt; &lt;filter id=\"Gaussian\"&gt; &lt;feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"20\"&gt; &lt;/feGaussianBlur&gt; &lt;/filter&gt; &lt;!-- 渐变必须写在defs里面 --&gt;&lt;/defs&gt;&lt;rect x=\"0\" y=\"0\" width=\"200\" height=\"200\" style=\"fill: url(#bg1);filter:url(#Gaussian)\"/&gt; 虚线 进度条123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; line &#123; stroke: #f40; stroke-width: 10px; /*这跟canvas的stroke功能相同*/ stroke-dasharray: 200px; stroke-dashoffset: 200px; /*虚线，虚线偏移量*/ animation: move 1s ease infinite alternate-reverse; &#125; @keyframes move&#123; from&#123; stroke-dashoffset: 200px; &#125; to&#123; stroke-dashoffset: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;svg width=\"500\" height=\"500\" style=\"border: 1px solid black\"&gt; &lt;line x1=\"100\" y1=\"100\" x2=\"300\" y2=\"100\"&gt;&lt;/line&gt; &lt;/svg&gt;&lt;/body&gt; 可视区（比例尺）viewbox 1234&lt;svg width=\"500\" height=\"500\" viewBox=\"0, 0, 250, 250\" style=\"border: 1px solid black\"&gt; &lt;!-- 现在已经发大了2倍 --&gt; &lt;rect height=\"50\" width=\"100\" x=\"0\" y=\"0\" rx=\"10\"&gt;&lt;/rect&gt;&lt;/svg&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"},{"name":"svg","slug":"svg","permalink":"http://www.hsiliver.space/tags/svg/"}]},{"title":"canvas","slug":"canvas","date":"2019-07-08T14:23:58.000Z","updated":"2019-07-09T02:43:54.694Z","comments":true,"path":"2019/07/08/canvas/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/canvas/","excerpt":"","text":"Canvas定义一个canvas的画布大小必须要在行间样式上定义，我们在&lt;style&gt;&lt;/style&gt;里面定义的只是canvas的一个科室范围并不是画布大小 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #can &#123; /*定义canvas的可视范围*/ width: 500px; height: 300px; border: 1px solid black; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"can\" width=\"500px\" height=\"300px\"&gt;&lt;/canvas&gt; &lt;script&gt; var can = document.getElementById('can'); var ctx = canvas.getContext(\"2d\"); // 在canvas上建立2d坐标系 ctx.beginPath(); // 开始之前建议加上这个 ctx.moveTo(100, 100); // 起点（落笔点） ctx.lineTo(200, 100); // 到200， 100坐标点 ctx.lineWidth = 10; // 线宽（无论写在哪都相当于写在最前面） ctx.closePath(); // 闭合（针对一笔来说的） ctx.fill(); // 填充 ctx.stroke(); // 将画笔抬起来（结束，之后才开始渲染页面） ctx.beginPath(); // 重新开启一个路径（重新落笔） ctx.lineWidth = 5; // 此时画笔粗细就可以改为5了 ctx.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 矩形1234567891011121314var can = document.getElementById('can');var ctx = canvas.getContext(\"2d\");ctx.rect(100, 100, 150, 100);// 起点坐标X，起点坐标Y，宽度，高度ctx.stroke();// 可以简写为这样ctx.strokeRect(100, 100, 200, 100);// 填充ctx.fillRect(100, 100, 200, 100);ctx.clearRect(0, 0, 300, 300);//橡皮檫（起点X，起点Y，宽， 高） 12345678var can = document.getElementById('can');var ctx = canvas.getContext(\"2d\");ctx.moveTo(100, 100);ctx.arc(100, 100, 50, 0, Math.PI / 4, 1);// （圆心起点X， 圆心起点Y，半径，起始弧度，终止弧度，[顺]逆时针） // 最后的 0 代表顺时针旋转，如果是 1 代表逆时针旋转； ctx.closePath();ctx.stroke(); 圆角矩形12345678910var can = document.getElementById('can');var ctx = canvas.getContext(\"2d\"); ctx.moveTo(100, 110); // 设置110是因为要让出圆角的位置ctx.arcTo(100, 200, 200, 200, 10);// B(x, y), C(x, y)[只是提供一个方向], 圆角大小ctx.arcTo(200, 200, 200, 100, 10);ctx.arcTo(200, 100, 100, 100, 10);ctx.arcTo(100, 100, 100, 200, 10);ctx.stroke(); 贝塞尔曲线二次 1234567var can = document.getElementById('can');var ctx = can.getContext(\"2d\");ctx.beginPath()ctx.moveTo(100, 100);ctx.quadraticCurveTo(200, 200, 300, 100)ctx.stroke(); 三次 1234567var can = document.getElementById('can');var ctx = can.getContext(\"2d\");ctx.beginPath()ctx.moveTo(100, 100);ctx.bezierCurveTo(200, 200, 300, 100, 400, 200)ctx.stroke(); 小波浪12345678910111213141516171819202122232425var can = document.getElementById('can');var ctx = can.getContext(\"2d\");// 在canvas上建立2d坐标系var width = 500;var height = 300;var offset = 0;var num = 0;setInterval(() =&gt; &#123; ctx.clearRect(0, 0, 500, 300); ctx.beginPath(); ctx.moveTo(0 + offset - 500, height / 2); ctx.quadraticCurveTo(width / 4 + offset - 500, height / 2 + Math.sin(num) * 120, width / 2 + offset - 500, height / 2); ctx.quadraticCurveTo(width / 4 * 3 + offset - 500, height / 2 - Math.sin(num) * 120, width + offset - 500, height / 2); ctx.moveTo(0 + offset, height / 2); ctx.quadraticCurveTo(width / 4 + offset, height / 2 + Math.sin(num) * 120, width / 2 + offset, height / 2); ctx.quadraticCurveTo(width / 4 * 3 + offset, height / 2 - Math.sin(num) * 120, width + offset, height / 2); ctx.stroke(); offset += 5; offset %= 500; num += 0.01;&#125;, 1000 / 30) 示例演示： 旋转、缩放12345678ctx.rotate(Math.PI / 6);// 以ctx坐标系为原点旋转（全局的）ctx.translate(100, 100)// 平移坐标系原点到100， 100（全局的）ctx.scale(2, 2);// 整个画布横纵坐标都放大2倍 保存、还原12345ctx.save();// 保存这个状态（一般用于要旋转或者改变原点坐标之前）ctx.restore();// 还原上次保存点的状态 填充1234567891011var img = new Image();img.src = \"./xxx.jpg\"; // src异步加载img..onload = function () &#123; ctx.beginPath(); var bg = ctx.createPattern(img, \"no-repeat\"); // 创建纹理 // ctx.fillStyle = \"orange\"; // 填充颜色 ctx.translate(100, 100); ctx.fillStyle = bg; // 从坐标系原点开始填充 ctx.fillRect(0, 0, 200, 100);&#125; 线性渐变12345678ctx.beginPath()var bg = ctx.createLinearGradient(0, 0, 500, 500);bg.addColorStop(0.1, 'red');bg.addColorStop(0.5, 'green');bg.addColorStop(1, 'yellow');ctx.fillStyle = bg; // 渐变点也是从画布原点开始的ctx.fillRect(0, 0, 500, 500) 辐射渐变123456var bg = ctx.createRadialGradient(100, 100, 0, 100, 100, 100);bg.addColorStop(0.1, 'red');bg.addColorStop(0.5, 'green');bg.addColorStop(1, 'yellow');ctx.fillStyle = bg;ctx.fillRect(0, 0, 200, 200) 阴影12345ctx.beginPath();ctx.shadowColor = \"black\";ctx.shadowBlur = 30; // 扩散值ctx.shadowOffsetX = 15; // x轴的阴影偏移量ctx.strokeRect(100, 100, 200, 200); 绘制文字12345ctx.beginPath();ctx.font = '30px Arail'ctx.strokeText('hsz', 200, 200); // 文字描边（空心）ctx.fillText('hahah', 200, 400); // 文字填充（实心） 线两端样式1ctx.lineCap = 'butt'; // 默认butt，square两端加上小方块，round两端加小半圆 12345678910ctx.beginPath();ctx.lineWidth = 20;ctx.lineCap = 'round'ctx.moveTo(110, 30);ctx.lineTo(200, 100);ctx.lineTo(110, 180);ctx.lineJoin = \"round\";// 默认miter 但是角度很小的时候会呈现被砍断状态\"bevel\"// 当为miter时，可以限制尖尖（miterLimit=xx 属性）ctx.stroke(); 获取图片转换为像素点12345678910var img = new Image();img.src = './xx.jpg';img.onload = function () &#123; ctx.drawImage(img, 100, 100, 400, 400, 100, 100, 300, 300); var data = oCanvas.toDataURL(); console.log(data); // 受同源策略的限制（要开启服务器） var info = ctx.getImageData(0, 0, 500, 500);// 获取像素点信息 console.log(info);&#125; canvas 转为编码12345678910var img = new Image(); img.src = './111.jpeg'; img.onload = function () &#123; ctx.drawImage(img, 100, 100, 400, 400, 100, 100, 300, 300); var data = oCanvas.toDataURL(); console.log(data); // 受同源策略的限制（要开启服务器） var info = ctx.getImageData(0, 0, 500, 500);// 获取像素点信息 console.log(info); &#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"},{"name":"canvas绘制","slug":"canvas绘制","permalink":"http://www.hsiliver.space/tags/canvas绘制/"},{"name":"贝塞尔曲线","slug":"贝塞尔曲线","permalink":"http://www.hsiliver.space/tags/贝塞尔曲线/"}]},{"title":"HTML5 标签篇","slug":"标签篇","date":"2019-07-08T14:20:58.000Z","updated":"2019-07-09T02:28:27.402Z","comments":true,"path":"2019/07/08/标签篇/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/标签篇/","excerpt":"","text":"标签篇我们用div可以写一整个页面，但是我们可以语义化标签，让维护变得更高效 123456789101112131415&lt;div&gt; 下面的这些标签本质上全是div，只是语义化了而已&lt;/div&gt;&lt;header&gt;头部&lt;/header&gt;&lt;footer&gt;尾部&lt;/footer&gt;&lt;nav&gt;内容部&lt;/nav&gt;&lt;article&gt; 文章，可以被引用拿走的 &lt;section&gt;段落式的，但事实上这俩并不用分的那么清楚&lt;/section&gt;&lt;/article&gt;&lt;aside&gt; 一般用作管理页面的侧边栏&lt;/aside&gt; canvas ( 画板 ) 1&lt;canvas&gt;详情在下一篇&lt;/canvas&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://www.hsiliver.space/tags/canvas/"},{"name":"标签","slug":"标签","permalink":"http://www.hsiliver.space/tags/标签/"}]},{"title":"HTML5 属性篇","slug":"属性篇","date":"2019-07-08T14:19:58.000Z","updated":"2019-07-09T02:42:21.930Z","comments":true,"path":"2019/07/08/属性篇/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/属性篇/","excerpt":"","text":"属性篇 placeholder 12&lt;input placeholder=\"用户名/手机/邮箱\"&gt;&lt;/input&gt;&lt;input type=\"password\" placeholder=\"请输入密码\"&gt; radio、check、file 123&lt;input type=\"radio\"&gt;&lt;input type=\"checkbox\"&gt;&lt;input type=\"file\"&gt; Calendar类( 需要form表单 ) 12345&lt;form&gt; &lt;input type=\"date\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;!-- 兼容性不好，目前只有Chrom支持，所以不常用 --&gt; 123456&lt;form&gt; &lt;input type=\"time\"&gt; &lt;input type=\"week\"&gt; &lt;input type=\"datetime-local\"&gt;&lt;/form&gt;&lt;!-- 兼容性不好，目前只有Chrom支持，所以不常用 --&gt; time week datetime-local 1234567891011121314151617&lt;input type=\"number\"&gt;&lt;/input&gt;&lt;!-- 兼容性不好, Safari, IE 不支持 --&gt;&lt;input type=\"email\"&gt;&lt;/input&gt;&lt;!-- 输入必须带 @ 兼容性不好, Safari, IE不支持， 谷歌火狐支持 --&gt;&lt;input type=\"color\"&gt;&lt;/input&gt;&lt;!-- 颜色选择器 兼容性不好, Safari, IE不支持 谷歌支持--&gt;&lt;input type=\"range\" min=\"1\" max=\"100\" name=range&gt;&lt;/input&gt;&lt;!-- 兼容性不好, 火狐, IE不支持 谷歌火狐支持 --&gt;&lt;input type=\"search\"&gt;&lt;/input&gt;&lt;!-- 搜索记忆功能 兼容性不好, Safari支持一点, IE不支持 谷歌火狐支持 --&gt;&lt;input type=\"url\"&gt;&lt;/input&gt;&lt;!-- 必须填完整网址 兼容性不好, Safari, IE不支持 谷歌火狐支持 --&gt; 只能输入数字 range contenteditable 将文本内容转为可写，兼容性良好，并且可以继承，父级有子集也会有。 但是子集也可以设置为false（不可写），虽然内部不可以编辑，但是在父级内部，自己外部， 依然是可以编辑的 1&lt;div contenteditable=\"true\"&gt;123&lt;/div&gt; Draggable ( 可拖拽的 ) a、img标签默认可拖拽 12345678910111213141516171819202122232425262728&lt;div class=\"able\" draggable=\"true\"&gt;&lt;/div&gt;&lt;!-- 兼容性不好 谷歌Safari支持 拖拽的生命周期（拖拽的组成）1. 拖拽开始，拖拽进行中，拖拽结束2. 被拖拽的物体，目标区域--&gt;&lt;script&gt; var oDragDiv = document.getElementsByClassName('able')[0]; var beginX = 0; var beginY = 0; oDragDiv.ondragstart = function (e) &#123; // 按下物体的瞬间是不会触发ondragstart事件的，移动开始的瞬间才开始触发 beginX = e.clientX; beginY = e.clientY; &#125; oDragDiv.ondrag = function (e) &#123; // 移动事件 &#125; oDragDiv.ondragend = function (e) &#123; // 结束事件 var X = e.clientX - beginX; var Y = e.clientY - beginY; oDragDiv.style.left = oDragDiv.offsetLeft + X + 'px'; oDragDiv.style.top = oDragDiv.offsetTop + Y + 'px'; &#125; // offsetLeft 获取的是相对于父对象的左边距 // pageX、pageY跟clientX和clientY类似，是相对于浏览器文档的坐标；&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .abled&#123; margin: 50px 0px 0px 100px; width: 140px; height: 170px; border: 2px solid black; border-radius: 3px; display: inline-block; &#125; ul&#123; padding: 0; &#125; li&#123; list-style: none; width: 100px; height: 40px; margin: 10px auto; background-color: #2FBDDF; border-radius: 5px; transition: all 0.3s; &#125; li:hover&#123; box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5); &#125; .target&#123; margin-left: 100px; width: 140px; height: 170px; border: 2px solid black; border-radius: 3px; display: inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"abled\"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"target\" draggable=\"true\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;!-- 1. 所有的标签元素，当拖拽结束时，默认事件是回到原处2. 事件是由行为触发的，一个行为可以不止触发一个事件3. ondragover ==&gt; 回到原处 ==&gt; 执行drop事件 A-&gt;B(阻止默认事件)-&gt;c（才可以执行）--&gt;&lt;script&gt; var dragDom; var liList = document.getElementsByTagName('li'); for (var i = 0; i &lt; liList.length; i++) &#123; liList[i].setAttribute('draggable', true); liList[i].ondragstart = function (e) &#123; dragDom = e.target; e.dataTransfer.effectAllowed = \"move\"; // 设置拖拽时的鼠标样式 只能在ondragstart里面使用 不常用 &#125; &#125; var oTarget = document.getElementsByClassName('target')[0]; oTarget.ondragover = function (e) &#123; e.preventDefault(); &#125; oTarget.ondrop = function (e) &#123; oTarget.appendChild(dragDom); dragDom = null; &#125; var abled = document.getElementsByClassName('abled')[0]; abled.ondragover = function (e) &#123; e.preventDefault(); &#125; abled.ondrop = function (e) &#123; abled.appendChild(dragDom); dragDom = null; e.dataTransfer.dropEffect = \"copy\"; // 设置拖拽放下时的鼠标样式 只能在ondrop里面使用 不常用 &#125; // 释放目标时触发的事件: // ondragenter - 当被鼠标拖动的对象进入其容器范围内时触发此事件 // ondragover - 当某被拖动的对象在另一对象容器范围内拖动时触发此事件 // ondragleave - 当被鼠标拖动的对象离开其容器范围内时触发此事件 // ondrop - 在一个拖动过程中，释放鼠标键时触发此事件&lt;/script&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"},{"name":"属性","slug":"属性","permalink":"http://www.hsiliver.space/tags/属性/"}]},{"title":"HTML 5大纲目录","slug":"h5目录","date":"2019-07-08T14:10:58.000Z","updated":"2019-07-09T02:24:35.172Z","comments":true,"path":"2019/07/08/h5目录/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/h5目录/","excerpt":"","text":"HTML 5大纲目录 1 新增的属性placeholder Calendar， data， time， email， url， search ContenEditable（标签内容是否可编辑） Draggable（是否可拖拽） Hidden（是否可隐藏） Content-menu Data-Val（自定义属性） 2 新增的标签语义化标签（一群类似div的功能） canvas（画板） svg（画板） Audio（声音播放） Video（视频播放） 3 API定位（需要地理位置的功能） 重力感应（陀螺仪） request-animation-frame（动画优化） History（控制当前页面的历史记录） LocalStorage，SessionStorage（储存信息，比如历史最高纪录） WebSocket（在线聊天，聊天室） FileReader（文件读取，预览） WebWorker（文件的异步，提升性能，提升交互体验） Fetch（传说中要替代Ajax的东西）","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"html","slug":"html","permalink":"http://www.hsiliver.space/tags/html/"},{"name":"HTML5","slug":"HTML5","permalink":"http://www.hsiliver.space/tags/HTML5/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-07-08T14:05:58.000Z","updated":"2019-07-09T02:08:29.842Z","comments":true,"path":"2019/07/08/正则表达式/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/正则表达式/","excerpt":"","text":"正则表达式作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择 最基本用法： 转移字符 “ \\ “ : 会把 \\ 后面的字符转为文本 “ \\n “ : 回车键 “ \\r “ : 该文本行结束 “ \\t “ : 一个tab（制表符缩进） 两种创建方式 直接量(常用) 12345var reg = /abc/; // 定义一个匹配abc的规则var str = 'abcd';reg.test(str); // 测试方法：是否符合上面的reg规则var reg = /abc/i; // 忽视大小写（ignoreCase） new RegExp(); 12345678910var reg = new RegExp(\"abc\", 'i');第二个值填匹配规则var str = 'ABCD';reg.test(str);// 效果同上var reg1 = new RegExp(reg)// reg1跟reg内容相同，但本质上不是同一个var reg2 = RegExp(reg);// reg跟reg2内容相同， 并且本质上是同一个人（当然也没什么人这么用） 1234567var reg = /ab/;var str = \"abbababab\";str.match(reg); // 返回[\"ab\"]// 如果全局匹配var reg = /ab/g;// 返回的就是所有的匹配正确的 [\"ab\", \"ab\", \"ab\", \"ab\"] 123var reg = /^a/g; // 匹配全局 以a开头 的所有符合要求的 [\"a\"]var str = \"abcde\\na\";var reg = /^a/gm; // m具有匹配多行的功能，[\"a\", \"a\"] 两种常用的方法 reg.test()：返回值只有true、false str.match() ： 返回具体匹配的项 123456// 当我们需要匹配多位的时候，就可以使用表达式“[]”了,里面填可以取到的范围var reg = /[1234567890][1234567890][1234567890]/g;// 还可以偷懒写 [0-9A-z], 正则也是符合ASCLL码匹配的// 全局匹配连着3位是数字0-9的符合要求的var str = \"123adsdaf45730258afdgw\";// [\"123\", \"457\", \"302\"] 1var reg = /(abc|bcd)/g; // 全局匹配abc或bcd，正则里的 “|” 代表或 元字符 1234567891011var reg = /\\w/g;/*/\\w === [0-9A-z_];\\W === [^\\w]; ==&gt;[非\\w]\\d === [0-9];\\D === [^\\d];同时表达式里面也是可以写元字符的 var reg = /[\\w]/g\\s === [空白字符] ==&gt; 空格( )，回车(\\r)， 制表(\\t)，换行(\\n)，垂直换行(\\v)，换页(\\f)\\S === [^\\s];/* 12345678910var reg = /\\bcde\\b/g;var str = \"abc cde fgh\";// [\"cde\"]// \\b === 单词边界// \\B === 非单词边界var reg = /[\\u0000-\\uffff]/g; // 匹配所有// . === [^\\r\\n]; 123456789var reg = /\\w+/g;// 全局匹配 \\w \"可以\" 出现无数次// n+ ==&gt; &#123;1, infinity&#125;// n* ==&gt; &#123;0, infinity&#125;// 贪婪匹配原则var reg = /\\w*/g;var str = \"abc\"; // [\"abc\", \"\"] 123var reg = /\\d*/g;var str = \"abc\"; // [\"\", \"\", \"\", \"\"]// 不能识别的就用会空代表 12345678var reg = /\\w?/g;var str = \"aaa\";// [\"a\", \"a\", \"a\", \"\"]// n? ==&gt; &#123;0, 1&#125;// n&#123;x, &#125; ==&gt; &#123;x, infinity&#125;// 贪婪匹配原则var reg = /\\w&#123;1, 3&#125;/g; // 全局匹配1-3个var str = \"aaaa\"; // [\"aaa\", \"a\"]; 1234var reg = /^sd$/g; // 以sd开头，以sd结尾var str = \"sd\"; // [\"sd\"]// n$ ==&gt; 以什么结尾// ^n ==&gt; 以什么开头 检验一个字符串，首尾是否含有数字的 正则表达式 12var reg = /^\\d|\\d$/;// 首尾都有数字 var reg = /^\\d[\\s\\S]*\\d$/ reg.exec()和reg.lastIndex(鼠标游标位置)，两者是相互配合使用的 如果不加 g 的话，lastIndex不会变，不动 123456789101112131415161718192021222324252627var reg = /ab/g;var str = \"abababab\";console.log(reg.exec(str));console.log(reg.lastIndex);// 2 [\"ab\", index: 0, input: \"abababab\", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 4 [\"ab\", index: 2, input: \"abababab\", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 6 [\"ab\", index: 4, input: \"abababab\", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 8 [\"ab\", index: 6, input: \"abababab\", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 0 nullconsole.log(reg.exec(str));console.log(reg.lastIndex);// 2 [\"ab\", index: 0, input: \"abababab\", groups: undefined] ()的记录功能 加上括号后括号就会记录里面的内容 123 var str = 'aaaa';var reg = /(\\w)\\1/g; // 全局匹配 \\w\\w , \\1（反向引用）类似复制一个与第一个子表达式一样的匹配表达式 12345var str = \"aabb\";var reg = /(\\w)\\1(\\w)\\2/g;console.log(reg.exec(str));// [\"aabb\", \"a\", \"b\", index: 0, input: \"aaaa\", groups: undefined]// 多出来的两位就是 第一个子表达式和第二个子表达式匹配的内容，而且这两位是正式的数据位 str.match() 123456var str = \"aabb\";var reg = /(\\w)\\1(\\w)\\2/;console.log(str.match(reg));// [\"aabb\", \"a\", \"b\", index: 0, input: \"aaaa\", groups: undefined]// 不加 全局g 的情况下， 返回的结果跟reg的exec方法类似// 一旦加了g 返回 [\"aabb\"]; str.search()返回匹配到的位置 123456var str = \"aabb\";var reg = /^bcd$/g;console.log(str.search(reg)); // 一旦匹配不到就返回 -1；var reg1 = /bb$/g;console.log(str.search(reg1)); // 2 \"0 a 1 a 2 b 3 b 4\",第二位匹配到 str.split()拆开，这个我们很熟悉，不过多解释 str.replace() 替换 12345678// 正常的replace:var str = \"aa\";console.log(str.replace(\"a\", \"b\")); // ba, 这就是非正则的缺陷，只能匹配1个// 再来换成正则表达式var reg = /a/;console.log(str.replace(reg)); // ba ，因为没有写 g（全局）var reg1 = /a/g;console.log(str.replace(reg1)); // bb eg : 形如 aabb 的都倒过来 1234567891011var reg = /(\\w)\\1(\\w)\\2/;var str = \"aabb\";console.log(str.replace(reg, \"$2$2$1$1\")); // 方法1console.log(str.replace(reg, function ($, $1, $2) &#123; // 第一个参数是正则表达式匹配的结果, // 第二个参数是第一个子表达式匹配的内容， // 第三个参数是第二个子表达式匹配的内容， return $2 + $2 + $1 + $1;&#125;))// str.toUpperCase(),变大写// str.toLowerCase(),变小写 eg : the-first-name ===&gt; theFirstName 1234567var reg = /-(\\w)/g;var str = \"the-first-name\";console.log(str.replace(reg, function ($, $1) &#123; return $1.toUpperCase(); // 里面的function是多次执行的&#125;))// 可以制作在线翻译功能 正向预查， 正向断言 1234567var str = \"abaaaaa\";var reg = /a(?=b)/g; // 全局匹配后面有 b 的 aconsole.log(str.match(reg)); // a// 意思是这个b参与匹配限定，但是不参与返回结果var reg = /a(?!b)/g; // 全局匹配后面没有 b 的 a ==&gt; 非正向预查console.log(str.match(reg));// [\"a\", \"a\", \"a\", \"a\", \"a\"]; 非贪婪匹配 12345var str = \"aaaa\";var reg = /a+/g; // 贪婪var reg1 = /a+?/g // 非贪婪var reg2 = /a&#123;1, 3&#125;?/g; // 有1绝对不取3，？可以打破任何规则var reg3 = /a??/g; // 能取0就不会取1， a? 匹配 0 ~ 1 位a 百度2014最后一道 123456789101112var str = \"10000000000\"; // 转换为形如 1,000,000,000var reg = /(?=(\\B)(\\d&#123;3&#125;)+$)/g; /*$ ==&gt; 从后往前查n+ ==&gt; &#123;1, infinity&#125;\\d ==&gt; &#123;0-9&#125;\\B ==&gt; 非单词边界？= ==&gt; 参与匹配限定，但是不参与返回结果()前面什么也不填 ==&gt; 匹配空*/ str.replace(reg, \".\");// 空替换为 \".\" 去重 123456var str = \"aaaaabbbbbccccc\";var reg = /(\\w)\\1*/g;// n* ==&gt; &#123;0~infinity&#125;;// 匹配所有 0到多个 ： [\"aaaaa\", \"bbbbb\", \"ccccc\"]str.replace(reg, \"$1\");// 将匹配到的替换成第一个子表达式","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://www.hsiliver.space/tags/正则表达式/"}]},{"title":"JSON","slug":"JSON","date":"2019-07-08T14:04:58.000Z","updated":"2019-07-09T02:07:31.657Z","comments":true,"path":"2019/07/08/JSON/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/JSON/","excerpt":"","text":"JSON JSON是一种数据传输的格式（以对象喂养版，本质上就是对象，但用途有区别，对象就是本地用的，JSON是用来传输的） 格式 属性名必须加双引号，属性值最好加 1234&#123; \"name\" : \"hsz\", \"age\" : 123&#125; 我们传输给后台的是字符串，后台传输给咱们的也是字符串，只不过是JSON格式的字符串&#39;{&quot;name&quot; : &quot;hsz&quot;, &quot;age&quot; : 123}&#39;, 下面这两种方法就是用来转化的 JSON.parse(); string ——&gt; json JSON.stringify(); json ——&gt; string renderTree一. DOM树的完成（2步）1 dom树的解析完成， 2 dom树的加载完成 dom树的解析 1 ） html解析原则：深度优先原则，一条道走到底 2 ） 识别到了就丢到dom树上去, 比如&lt;img src=&quot;&quot;&gt;, dom树不会去管src的内容，认识&lt;img&gt;就完事了 二. CSS树（跟DOM树类似）renderTree = DOMTree + CSSTree当renderTree形成完成后，JavaScript引擎才会开始真正开始绘制页面，按照renderTree里面的每一条规则去绘制页面 三 .renderTree的重排（reflow）和重绘（repaint）renderTree的重排会降低代码运行的效率 1）dom节点的删除，增加 2） dom节点的宽高变化，位置变化 3） offsetLeft offsetWidth（因为要求实时获取，所以要不断重排） renderTree重绘会极少的降低效率（可以接受） dom节点的颜色改变 异步加载为什么js的加载过程和运行过程不能和html、css并行去做呢？ 因为js会修改html和css，要么绘制完了运行，要么运行完了继续绘制 为什么&lt;script&gt;&lt;/script&gt; 要放在最后呢？ 因为如果放在head里面，但凡js里面有一个字节没加载过来，整个页面就废掉了 异步加载三个方案1）defer 异步加载，但要等到dom文档全部解析完才会被执行。可以加载内部脚本 123&lt;script type=\"text/javascript\" src=\"\" defer=\"defer\"&gt; // 但是很遗憾，只有IE9以下可以用&lt;/script&gt; 加上defer后就可以和html，css同时加载了 2） async 异步加载，加载完就执行，async只能加载外部脚本，不可以加载&lt;script&gt;的内部脚本 123&lt;script type=\"text/javascript\" src=\"\" async=\"async\"&gt; // W3C标准方法，只能加载外部脚本&lt;/script&gt; 上面俩，执行时也不会阻塞页面 3）动态创建script，插入到dom中，加载完毕后callback（最常用），还可以按需加载 1234var script = document.createElement('script');script.type = \"text/javascript\";script.src = \"./xxx.js\"; // 开始下载\"xxx.js\"document.head.appendChild(script); // 开始执行\"xxx.js\" 如果我们想要执行xxx.js里面的方法的话，就需要等到xxx.js下载完成才可能执行 当然我们也有这样的方法 1234567script.onload = function () &#123;&#125; // 就IE不好使script.onreadystatechange = function () &#123; if(script.readState == \"complete\" || script.readyState == \"loaded\")&#123; // ie独有 &#125;&#125; 我们可以封装到一起 1234567891011121314151617181920212223242526272829function loadScrpit(url, callback) &#123; var script = document.createElement('script'); script.type = \"text/javascript\"; if (script.readyState) &#123; script.onreadystatechange = function () &#123; if(script.readState == \"complete\" || script.readyState == \"loaded\")&#123; // 1 callback();// ie独有 // 2 eval(callback); tools[callback](); &#125; &#125; &#125;else &#123; script.onload = function () &#123; // 1 callback(); tools[callback](); &#125; &#125; script.src = url;// 开始下载\"xxx.js\" document.head.appendChild(script); // 开始执行\"xxx.js\"&#125;// 1 loadScrpit('tools.js', function () &#123;test()&#125;)// 2 loadScrpit('tools.js', \"test()\");loadScrpit('tools.js', \"test\");// 但是第三种要求这样写函数体var tools = &#123; test : function () &#123;console.log('a');&#125;, demo : function () &#123;&#125;;&#125; js 加载时间线 1 创建Document对象，开始解析对象，开始解析web页面。解析HTML元素和他们的文本内容后，添加Element对象和Text节点到文档中，这个阶段document.readyState = &#39;loading&#39;. 2 遇到link外部css，创建线程加载，并继续解析文档。 3 遇到script外部js，并且没有设置async、defer。浏览器加载并阻塞，等待加载完成并执行该脚本，然后继续解析文档。 4 遇到script外部js，并且设置有async、defer。浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后执行。（异步禁止使用document.write()） 5 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 6 当文档解析完成，document.readyState = &#39;interactive&#39;。 7 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async不同，但同样禁止document.write()）。 8 document对象触发DOMContentLoaded事件，这也标志着程序执行从 同步脚本执行阶段 转化为事件驱动阶段。(只在addEventListener()好用) 9 当所有async的脚本加载完成并执行后、img的加载完成后，document.readyState = &#39;complete&#39;，window对象触发load事件。 10 从此，以异步响应方式处理用户输入、网络事件等。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"js时间线","slug":"js时间线","permalink":"http://www.hsiliver.space/tags/js时间线/"},{"name":"异步加载","slug":"异步加载","permalink":"http://www.hsiliver.space/tags/异步加载/"},{"name":"JSON","slug":"JSON","permalink":"http://www.hsiliver.space/tags/JSON/"}]},{"title":"事件 —— 交互体验的核心功能","slug":"事件","date":"2019-07-08T14:04:58.000Z","updated":"2019-07-09T02:07:55.719Z","comments":true,"path":"2019/07/08/事件/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/事件/","excerpt":"","text":"事件 —— 交互体验的核心功能 ele.onxxx = function (event) {} 兼容性很好，但是一个元素的同一个事件上只能绑定一个处理程序 基本等同于写在HTML行间上（句柄绑定方式） obj.addEventListener(type, fn, false); IE9 以下不兼容，可以为一个事件绑定多个处理程序（地址不一样的fn） obj.attachEvent(&#39;on&#39;+type, fn); IE 独有，一个事件同样可以绑定多个处理程序 123456789101112131415161718&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 点击输出li的序号 window.onload = function () &#123; var oUl = document.getElementsByTagName('ul')[0]; var oLi = document.getElementsByTagName('li'); for (let i = 0; i &lt; oLi.length; i++) &#123; oLi[i].addEventListener('click', function () &#123; console.log(i); &#125;) &#125; &#125;&lt;/script&gt; 封装兼容性事件监听 1234567891011function addEvent(ele, type, handle) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, handle, false); &#125;else if (ele.attachEvent) &#123; ele.attachEvent('on' + type, funciton () &#123; handle.call(ele) &#125;) &#125;else &#123; ele['on' + type] = handle; &#125;&#125; 解除事件 dom.removeEventListener(&#39;click&#39;, fn, false); dom.detachEvent(&#39;on&#39; + type, fn); 事件处理模型——事件冒泡、捕获 事件冒泡： 结构上（非视觉上）嵌套关系的元素， 会存在事件冒泡的功能，即同一时间，自子元素冒泡向父元素（自底向上） 事件捕获： 1 dom.addEventListener()第三个参数为true 2 dom.setCapture(); （仅在IE上好使）捕获页面上所有的事件捕获到自己身上 ​ 对应dom.releaseCapture(); （取消事件捕获） 结构上（非视觉上）嵌套关系的元素， 会存在事件捕获的功能，即同一时间，自父元素捕获至子元素（自顶向下） IE没有捕获事件, 只有谷歌实现了 出发顺序， 先捕获，后冒泡 focus、blur、change、submit、reset、select等事件不冒泡 阻止事件冒泡 123456789101112div.onclick = function (e) &#123; var event = e || window.event;//在IE里(e)不好使 var target = event.target || event.srcElement;//兼容事件源对象 stopBubble(e);&#125;function stopBubble(event) &#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 阻止默认事件 默认事件——表单提交，啊标签跳转，右键菜单等 return false 以对象属性的方式注册的事件才生效（句柄绑定事件生效） event。preventDefault() W3C 标注， IE9以下不兼容 event.returnValue = false 兼容IE 封装阻止默认事件的函数 cancelHandler(event) 1234567891011div.onclick = function (e) &#123; var event = e || window.event; cancelHandler(e);&#125;function cancelHandler(event) &#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 事件对象 谷歌：window.e || e IE：window.event || event 事件源对象 火狐只有event.target IE只有 event.srcElement google :都有 123// 兼容性写法var event = e || window.event;var target = event.target || event.srcElement; 事件委托 优点： 1 性能 ： 不需要循环所有元素一个个绑定 2 灵活 ： 当有新的子元素时不需要重新绑定事件 1234567891011&lt;ul id=\"ul\"&gt; &lt;li&gt;&#123;$1&#125;&lt;/li&gt; * 100&lt;/ul&gt;&lt;script&gt; var oUl = document.getElementsByTagName('ul')[0]; oUl.onclick = funciton (e) &#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target.innerText); &#125;&lt;/script&gt; 鼠标事件 click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、mouseenter、mouseleave 用button来区分鼠标按键 0 / 1 / 2 W3C标准规定：click事件只能监听左键，，只能通过mousedown和mouseup来判断鼠标键 div拖拽事件 123456789101112131415161718var div = document.getElementsByTagName('div')[0];function drag(dom) &#123; var e = e || window.event; var disX, disY; div.onmousedown = function (e) &#123; disX = e.pageX - parseInt(dom.style.left); disY = e.pageY - parseInt(dom.style.top); document.onmousemove = function (e) &#123; dom.style.left = e.pageX - disX + 'px'; dom.style.top = e.pageY - disY + 'px'; &#125; div.onmouseup = function () &#123; document.onmousemove = null; &#125; &#125;&#125;drag(div) 判断鼠标左右键 1234567document.onmousedown = function (e) &#123; if (e.button == 2) &#123; console.log('右键'); &#125;else &#123; console.log('左键'); &#125;&#125; 如何解决onmousedown和onmouseup与onclick事件冲突 利用用户习惯的事件差设置就可以避免了 123456789101112131415161718var firstTime = 0;var lastTime = 0;var key = true;document.onmousedown = function () &#123; firstTime = new Date().getTime();&#125;document.onmouseup = function () &#123; lastTime = new Date().getTime(); if (lastTime - firstTime &lt; 300) &#123; key = true; &#125;&#125;document.onclick = function () &#123; if (key) &#123; console.log('click'); key = false; &#125;&#125; 移动端：touchstart 、touchmove、touchend 键盘类事件 onkeypress &gt;onkeydown &gt; onkeyup keydown可以相应任意键盘按键，keypress止咳响应字符类键盘按键 keypress返回ASCLL码，可以转换成相应字符 1234document.onkeypress = function (e) &#123; console.log(String.fromCharCode(e.charCode)); // 将ASCLL码转换为键盘上对应的字符&#125; 文本类操作事件 input输入触发、focus聚焦触发、blur失焦触发、change改变内容并且失焦触发 窗体操作类（window上的事件） scroll当滚动轮滚动触发 （懒加载） load （尽量少用）整个页面全部就绪的时候，才执行window.onload,虽然很飘逸，但是效率很低，影响用户体验，但是也有好处：比如广告要等到页面加载完才加上广告。也可以考究需要多久，页面能够正常使用","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"冒泡","slug":"冒泡","permalink":"http://www.hsiliver.space/tags/冒泡/"},{"name":"事件","slug":"事件","permalink":"http://www.hsiliver.space/tags/事件/"}]},{"title":"日期对象Date()","slug":"date对象、定时器","date":"2019-07-08T14:03:58.000Z","updated":"2019-07-09T02:18:55.052Z","comments":true,"path":"2019/07/08/date对象、定时器/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/date对象、定时器/","excerpt":"","text":"日期对象Date()日期对象：是系统提供好的 注意： 我们new出来的对象是记录的date出生的那一刻，并不是实时地 123456789101112131415161718192021var date = new Date();date.getDate(); // 返回当前这个月的第几天。就是几号（1 ~ 31）date.getDay(); // 返回当前周的第几天（0 ~ 6）date.getMonth(); // 返回当前年的第几个月 （0 ~ 11）date.getFullYear(); // 返回当前年份（四位数）date.getHours(); // 返回当前小时（0 ~ 23）date.getMinutes(); // 返回当前分钟（0 ~ 59）date.getSeconds(); // 返回当前秒钟（0 ~ 59）date.getMilliseconds(); // 返回当前毫秒（0 ~ 999）date.getTime(); // *返回 1970 年 1 月 1 日至今的毫秒数（计算机的纪元时刻，也是最常用的）date.setDate(); // 设置月的第几天。就是几号（1 ~ 31）date.setDay(); // 设置周的第几天（0 ~ 6）date.setMonth(); // 设置年的第几个月 （0 ~ 11）date.setFullYear(); // 设置年份（四位数）date.setHours(); // 设置小时（0 ~ 23）date.setMinutes(); // 设置分钟（0 ~ 59）date.setSeconds(); // 设置秒钟（0 ~ 59）date.setMilliseconds(); // 设置毫秒（0 ~ 999）date.setTime(); // 以毫秒设置date对象 定时循环器setInterval(function () {}, time) 1234var time = 1000;setInterval(function () &#123;&#125;, time);time =2000;// 事实上这个 setInterval 里面的 time 只识别一次，即使在后面再次修改也是不好使的 我们可以来验证定时器到底准不准 123456789var firstTime = new Date().getTime();setInterval(function () &#123; var lastTime = new Date().getTime(); console.log(lastTime - firstTime); firstTime = lastTime;&#125;, 1000)// 结果是很不准的setInterval(\"console.log('a')\", 1000); // 另一种写法每隔1000毫秒运行字符串里面的代码 定时器setTimeout(function () {}, 1000) 只运行一次，运行完成后结束，用法与setInterval相差无几 清除定时、定时循环器clearInterval(); 1234var timer = setInterval(function () &#123;&#125;, 1000);var timer2 = setInterval(function () &#123;&#125;, 2000);console.log(timer, timer2); // 1 2clearInterval(timer); 由于setInterval是window上的一个方法，而每生成一个setInterval，window就会给这个setInterval打上一个唯一标识；我们清除的就是这个标识；","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"Date","slug":"Date","permalink":"http://www.hsiliver.space/tags/Date/"},{"name":"定时器","slug":"定时器","permalink":"http://www.hsiliver.space/tags/定时器/"}]},{"title":"获取视口属性，脚本化css","slug":"获取视口属性，脚本化css","date":"2019-07-08T14:03:58.000Z","updated":"2019-07-09T02:05:28.304Z","comments":true,"path":"2019/07/08/获取视口属性，脚本化css/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/获取视口属性，脚本化css/","excerpt":"","text":"滚动条查看滚动条的滚动距离 window.pageXOffset / pageYOffset IE 8 及 iIE8以下不兼容 document.body / documentElement.scrollLeft / scrollTop 兼容性比较混乱呢，用时取俩值相加，因为不可能存在两个同时有值 封装兼容性方法，求滚动轮滚动距离 getScrollOffset() 12345678910111213function getScrollOffset() &#123; if (window.pageXOffset) &#123; return &#123; x : window.pageXOffset, y : window.pageYOffset &#125; &#125;else &#123; return &#123; x : document.body.scrollLeft + document.documentElement.scrollLeft, y : document.body.scrollTop + document.documentElement.scrollTop, &#125; &#125;&#125; 让滚动条滚动 window上有3个方法 scroll(),scrollTo(),scrollBy() 三个方法功能类似，用法都是x, y 坐标传入。即实现让滚动轮滚动到当前位置。 区别：scrollBy()会在之前的数据基础之上做累加 eg ： 可以利用scrollBy() 快速阅读的功能 视口查看视口尺寸 window.innerWidth/innerHeight IE8及IE8以下不兼容 document.documentElement.clientWidth / clientHeight 标准模式下，任意浏览器都兼容 document.body.clientWidth / clientHeight 适用于怪异模式下的浏览器 封装兼容性方法，返回浏览器视口尺寸getViewportOffset() 1234567891011121314151617181920function getViewportOffset() &#123; if (window.innerWidth) &#123; return &#123; w : window.innerWidth, h : window.innerHeight &#125; &#125;else &#123; if (document.compatMode === \"BackCompat\") &#123; return &#123; w : document.body.clientWidth, h : document.body.clientHeight &#125; &#125;else &#123; return &#123; w : document.documentElement.clientWidth, h : document.documentElement.clientHeight &#125; &#125; &#125;&#125; 元素尺寸查看元素几何尺寸 domEle.getBoundingClientRect() 兼容性很好 该方法返回一个对象，对象里面有left、top、right、bottom等属性。left和top代表该元素左上角的X坐标和Y坐标，right和bottom代表该元素右下角的X坐标和Y坐标。 height和width属性老IE并未实现 返回的结果并不是实时的 查看元素尺寸 ( 视觉上的尺寸 ) dom.offsetWidth, dom.offsetHeight 查看元素位置 dom.offsetLeft, dom.offsetTop 对于无定位的父级元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。无论自身有没有定位，但凡与父级或者文档有距离就返回这个距离 dom.offsetParent 返回最近的由定位的父级，如果没有，返回body，body.offsetParent返回null。 eg : 求元素相对于文档的坐标 getElementPosition 脚本化cssdom.style（获取的是行间样式） 可读可写 注意background-color 等，带 ‘-‘ 号的组合样式, 要小驼峰式命名backgroundColor 碰到float这样的保留字属性，前面加css ——&gt; dom.style.cssFloat = left; 复合属性（一个样式包含多个属性，比如border）尽量拆开写 查询计算样式（已经计算完了，比如 em —&gt; px） window.getComputedStyle(ele, null)[prop]; 这个方法可以获取伪元素的样式 1window.getComputedStyle(div, 'after').width // 这样就可以获取了 计算样式只读（视觉上展示给我们的样式会展示出来，包括默认值） 返回的计算样式的值都是绝对值，没有相对单位 IE8及IE8以下不兼容 IE：dom.currentStyle[prop]但是并非是计算后的属性 12345678// 封装兼容的 查询计算样式function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125;else &#123; return elem.currentStyle[prop]; &#125;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"滚动条","slug":"滚动条","permalink":"http://www.hsiliver.space/tags/滚动条/"},{"name":"视口","slug":"视口","permalink":"http://www.hsiliver.space/tags/视口/"},{"name":"脚本化css","slug":"脚本化css","permalink":"http://www.hsiliver.space/tags/脚本化css/"}]},{"title":"DOM详解","slug":"DOM","date":"2019-07-08T14:00:58.000Z","updated":"2019-07-09T02:18:23.089Z","comments":true,"path":"2019/07/08/DOM/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/DOM/","excerpt":"","text":"DOM什么是DOM？ DOM ——&gt; Document Object Model DOM 定义了表示和修改文档所需的方法，DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对Html以及xml的标准编程接口。 XML ——&gt; XHTML ——&gt; html, Xml里面的标签可以自定义 操作不了CSS，但是可以通过操作行间样式，间接操作CSS 12345678910111213141516&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.style.width = '100px'; div.style.height = '100px'; div.style.backgrounColor = 'orange'; var count = 0; div.onclick = function () &#123; count ++; if (count % 2 == 1) &#123; this.style.backgrounColor = 'yellow'; &#125;else &#123; this.style.backgrounColor = 'orange'; &#125; &#125;&lt;/script&gt; DOM的基本操作1) 对节点的改查 查看元素节点 123456789101112131415161718document // 代表整个文档document.getElementById(); // 元素ID在IE8以下的浏览器，不区分ID大小写，而且也返回匹配name属性的元素&lt;div name=\"div\"&gt;&lt;/div&gt;document.getElementsByTagName(); // 标签名document.getElementsByName(); // 需要注意，只有部分标签name可以生效（表单，表单元素，img，iframe）document.getElementsByClassName(); // 类名，-&gt; IE8和IE8以下的IE版本中没有，可以选中多个classdocument.querySlector() // css选择器，IE7和IE7以下的IE版本中没有,选一个document.querySlector('div &gt; span.demo');// 事实上这两个并不使用，因为是静态的，选中一次后，// 后面再次选中依然以第一次选中的结果为主，是非实时的，镜像的document.querySlectorAll() // css选择器，IE7和IE7以下的IE版本中没有document.querySlector('div &gt; span.demo'); 遍历节点树 1234567891011parentNode -&gt; 父节点（一个元素只有一个父节点）childNodes -&gt; 子节点们firstChild -&gt; 第一个子节点lastChild -&gt; 最后一个子节点nextSibling -&gt; 后一个兄弟节点previousSibling -&gt;前一个兄弟节点 基于元素节点树的遍历 1234567891011parentElement -&gt; 返回当前元素的父元素节点（IE不兼容）children -&gt; 只返回当前元素的子元素节点（兼容性最好，最常用）node.childElementCount === node.children.length -&gt; 当前元素节点的子节点firstElementChild -&gt; 返回的是第一个元素节点（IE不兼容）lastElementChild -&gt; 返回的是最后一个元素节点（IE不兼容）nextElementSibling / previousElementSibling -&gt; 返回后一个/前一个兄弟元素节点 节点的类型 12345678nodeType —&gt; 获取节点的类型， 只读元素节点 ———— 1属性节点 ———— 2文本节点 ———— 3注释节点 ———— 8document —— 9DocumentFragment(文本碎片节点) ———— 11 节点的四个属性 12345678910111213nodeName -&gt; 元素的标签名，大写形式表示 ， 只读nodeValue -&gt; text节点或Comment节点的文本内容 ， 可读可写nodeType —&gt; 该节点的类型， 只读attributes -&gt; Element 节点的属性集合&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;div.attributes[0].name; // iddiv.attributes.value; // demovalue值可读可写，name值只读节点的一个方法 node.hasChildNodes();返回true/false 1234HTMLDocument.prototype = &#123; __proto__ : Document.prototype&#125;// 所以继承关系是：document --&gt;(继承自) HTMLDocument.prototype --&gt; Document.prototype getElementById方法定义在Document.prototype上，即Element节点上不能使用。 getElementByName方法是在HTMLDocument.prototype上， 即非html中的document不能使用（xml、document、Element） getElementByTagName方法定义在Document.prototype和Element.prototype上 12var div = document.getElemmentsByTagName('div')[0];var span = div.getElementsByTagName('span')[0]; HTMLDocument.prototype定义了一些常用的属性，body，head分别指代HTML文档中的&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt;标签 12document.body; //&lt;body&gt;&lt;/body&gt;document.head; //&lt;head&gt;&lt;/head&gt; Document.prototype上定义了document、Element属性，指代文档的根元素，在HTML文档中，它总是指代&lt;html&gt;&lt;/html&gt;元素 1document.documentElement; // &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; getElementsByClassName、querySelector、querySelectorAll在Document.prototype、Element.prototype类中均有定义 练习12345678// 封装函数，返回元素e的第n层祖先元素节点function retParent(elem, n) &#123; while (elem &amp;&amp; n) &#123; elem = ele.parentElement; n --; &#125; return elem;&#125; 1234567891011121314151617181920212223// 封装函数，返回元素e的第n个元素节点，n为正，//返回后面的元素节点，n为负，返回前面的，n为0返回自己function retSibling(e, n) &#123; while (e &amp;&amp; n) &#123; if (n &gt; 0) &#123; if (e.nextElementSibling;) &#123; e = e.nextElementSibling; &#125;else &#123; for (e = e.nextSibling; e &amp;&amp; e.nodeType ! = 1; e = e.nextSibling) // 为了兼容IE9以下 &#125; n --; &#125;else &#123; if (e.previousElementSibling) &#123; e = e.previousElementSibling; &#125;else &#123; for (e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling); &#125; n ++; &#125; &#125; return e;&#125; 1234567891011// 编辑函数，封装myChildren功能，解决以前部分浏览器的兼容性问题Element.prototype.myChildren = function () &#123; var child = this.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i ++) &#123; if (chilid[i].nodeType == 1) arr.push(child[i]) &#125; return arr;&#125; 1234567891011// 封装hasChildren()方法，不可用children属性Element.prototype.hasChildren = function () &#123; var child = this.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i ++) &#123; if (chilid[i].nodeType == 1) return true; &#125; return false;&#125; 12345678910111213141516// 封装自己的chlidren函数，用nodeTypefunction retElementChild(node) &#123; var temp = &#123; length : 0, push : Array.prototype.push, splice : Array.prototype.splice; &#125;, child = node.childNodes, len = child.length; for (var i = 0; i &lt; len; i ++) &#123; if (child[i].nodeType === 1) &#123; temp.push(child[i]); &#125; &#125; return temp;&#125; 2） 对节点的增、插、删、替换 增 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createComment() 创建注释节点 document.createDocumentFragment() 创建文档碎片节点 插 ParentNode.appendChild() parentNode 里面 ，列表的最后插入子节点（剪切操作） ParentNode.insertBefore(a, b) parentNode 里面 ，把 a 插入在 b 之前 123456789101112131415// 封装insertAfter函数// &lt;div&gt;// &lt;span&gt;&lt;/span&gt;// &lt;p&gt;&lt;/p&gt;// &lt;div&gt;Element.prototype.insertAfter = function (targetNode, afterNode) &#123; // &lt;i&gt; &lt;p&gt; var beforeNode = afterNode.nextElementSibling; if (beofreNode == null) &#123; this.appendChild(targetNode) &#125;else &#123; this.insertBefore(targetNode,beforeNode); &#125;&#125; 删 parent.removeChild() 删除（剪切出来）自己的子节点（参数可以是某个节点） child.remove() 删除（销毁）自己 替换 parent.replaceChild(new, origin)父级调用，拿新的元素替换老的元素 Element节点上的一些属性 innerHTML —-&gt;读 / 写html结构，覆盖原有所有内容 12div.innerHTML; // 取值操作div.innerHTML = '&lt;p&gt;&lt;/p&gt;'; // 写入操作 innerText(火狐不兼容) / textContent（老版本IE不好使） —&gt; 读 / 写文本内容，覆盖原有所有内容，包括标签结构，所以谨慎使用 Element 节点上的一些方法 ele.setAttribute(); 设置行间属性 1234&lt;div&gt;&lt;/div&gt;div.setsetAttribute(&apos;class&apos;, &apos;demo&apos;);===&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; ele.getAttribute();获取行间属性，里面填一个参数即可","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"DOM的基本操作","slug":"DOM的基本操作","permalink":"http://www.hsiliver.space/tags/DOM的基本操作/"},{"name":"节点树","slug":"节点树","permalink":"http://www.hsiliver.space/tags/节点树/"}]},{"title":"try {} catch (e) {}","slug":"try...catch,es5严格模式","date":"2019-07-08T13:59:58.000Z","updated":"2019-07-09T02:13:44.855Z","comments":true,"path":"2019/07/08/try...catch,es5严格模式/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/try...catch,es5严格模式/","excerpt":"","text":"try {} catch (e) {} 防止部分的代码出错，影响后续代码的执行 try 里面的代码如果都正确，catch里面的代码就不执行，否则catch里面的代码执行 123456789101112try &#123; console.log('a'); console.log(b); console.log('c'); // 到第二个console 的时候; 不执行，但是try外边的 \"h\" 依然被执行 &#125;catch (e) &#123; console.log(e); // catch 的作用就是把try里面的错误捕捉到， // 然后把（error.message error.name）封 // 装到一个error对象里面, 然后传给e，供我们使用&#125;console.log('h'); 在不知道后台传来data数据是否有错误的时候，这个是非常方便 Error.name 的六种值对应的信息1）EvalError : eval() 的使用与定义不一致 2）RangeError : 数值越界 3）ReferenceError : 非法或不能识别的引用数值 *** ​ 例如：未经声明就使用 4）SyntaxError : 发生语法解析错误 *** ​ 例如：出现中文符号 5）TypeError : 操作数据类型错误 ** 6）URLError : URL处理函数使用不当 ES5严格模式 目前我们使用的浏览器都是基于es3.0 的 + es5.0 的新增方法 使用的; 如果他俩产生冲突就会以es5.0为准, 否则使用es3.0， 定义为 “es5.0严格模式” 启动开关：”use strict”; 必须写在逻辑的最顶端； 12345\"use strict\";function test() &#123; console.log(arguments.callee) // 报错如下 caller一样&#125;// Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them 两种用法： 全局严格模式 局部函数内部严格模式 必须要在支持es5的浏览器上才可以 不支持with () {} 123456789101112131415161718var obj = &#123;name : \"obj\"&#125;;var name = 'window';function test() &#123; var name = 'scope'; width(obj) &#123; console.log(name); &#125; // with里面的代码会按照正常顺序执行， // 但是当with传一个对象后就发生了大变化， // 它会把这个对象当做with要执行的代码体的作用域链的最顶端； // 也就是会作用域链改变 // with跟命名空间配合使用，可以发挥很大的功效 width (document) &#123; write ('a') &#125; // 但是with 会更改作用域链，使代码运行效率变得非常慢&#125;test(); 变量赋值前必须声明 局部的this必须被赋值或者外部new，而且赋什么就是什么，否则指向空（undefined） （可以使用call / apply） 12345\"use strict\";funciton test() &#123; console.log(this); // 123&#125;test.call(123); 在非严格模式下，test.call(原始值)是坚决不行的，会给你包装成包装类Number {123} 全局下的console.log(this); 指向window； 拒绝重复的属性和参数，重复属性不报错，重复参数报错 不允许使用eval（）; 可以把字符串当成代码执行 1eval('console.log(123)'); // 123 可以改变作用域","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"try{}catch(e){}","slug":"try-catch-e","permalink":"http://www.hsiliver.space/tags/try-catch-e/"},{"name":"es5严格模式","slug":"es5严格模式","permalink":"http://www.hsiliver.space/tags/es5严格模式/"}]},{"title":"数组","slug":"数组","date":"2019-07-08T13:58:58.000Z","updated":"2019-07-09T02:10:03.743Z","comments":true,"path":"2019/07/08/数组/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/数组/","excerpt":"","text":"数组 var arr = []; var arr = new Array() 这两种都是系统定义的，所以说数组能用的一切方法都来源于Array.prototype 这俩的唯一区别 12var arr = [10]; // [10] 推荐这种使用方法var arr1 = new Array(10); // [undefined*10] 长度为10的空数组，但是千万不能填小数 数组的读和写可以溢出读，溢出写 数组常用的方法改变原数组 push —— 在数组最后一位添加 123456Array.prototype.push = function () &#123; for (var i = 0; i &lt; arguments.length; i ++) &#123; this[this.length] = arguments[i] &#125; return this.length&#125; pop —— 从最后一位剪切出来（传参也没用） shift —— 从第一位添加 unshift —— 从第一位开始剪切（传参也没用） sort() 12var arr = [1, 7, 5, 10];arr.sort(); // [1, 10, 5, 7] 按照ASCll码排序（降序） 由于sort很大可能满足不了我们的开发需求，所以开发者特地给我们留了一个接口 供我们自己编写 123456789// 1 必须写俩形参// 2 看返回值// 1) 当返回值为负数时， 那么前面的数放在前面 小 - 大 &lt; 0// 2) 为正数时， 后面的数在前 大 - 小 &gt; 0// 3) 为0， 不动arr.sort(function (a, b) &#123; // return b - a;降序 return a - b; // 升序&#125;) 12345// 给一个有序的数组乱序var arr = [1, 2, 3, 4, 5, 6, 7];arr.sort(function () &#123; return Math.random() - 0.5;&#125;) reverse ——原数组逆转 splice —— 切片 123456var arr = [1, 2, 3, 4];// arr.splice(从地位开始, 截取多少长度, 在切口出添加新的数据) 还会返回截取出的数据console.log(arr.splice(1, 2, 5)) // (2)[1, 2] (3)[1, 5, 4]arr.splice(3, 0, 'haha') // [] (4) [1, 5, 4, \"haha\"]arr.splice(-1, 1) // 截取的是倒数第一位// 就是 -1 + arr.length 不改变原数组 concat ——连接 123var arr = [1, 2, 3];var arr1 = [6, 7, 8];arr.concat(arr1); // [1, 2, 3, 6, 7, 8] join 12var arr = [1, 2, 3];arr.join(\"-\"); // \"1-2-3\"; 最好还是填字符串，当然原始值都可以 split 123var str = \"1-2-3-4-5\";str.split(\"-\");// [\"1\", \"2\", \"3\", \"4\", \"5\"]; toString 12var arr = [1, 2, 3];arr.toString(); // \"1, 2, 3\" slice 1234var arr = [1, 3, 4];var newArr= arr.slice(1, 3); // [3, 4]// slice(从该位开始截取，截取到该位), 不写参数就全截取 类数组 属相为索引（数字）属性 必须要有lenngth属性 最好加上push 123456789101112131415var obj = &#123; \"0\" : 'a', \"1\" : 'b', \"2\" : 'c', \"length\" : 3, \"push\" : Array.prototype.push, \"splice\" : Array.prototype.splice // 当我们加上splice后 [\"a\", \"b\", \"c\", push: ƒ, splice: ƒ] 就变成这样了&#125;// 里面的push会有这样一个操作Array.prototype.push = function (target) &#123; obj[obj.length] = target; obj.length ++;&#125; 12345678910var obj = &#123; \"2\" : 'a', \"3\" : 'b', \"length\" : 2, \"push\" : Array.prototype.push&#125;console.log(obj); // &#123;2: \"a\", 3: \"b\", length: 2, push: ƒ&#125;obj.push('c');obj.push('d'); console.log(obj); // &#123;2: \"c\", 3: \"d\", length: 4, push: ƒ&#125; 123function test() &#123; console.log(typeof arguments); // object&#125; 12345var h = function a() &#123; return 23;&#125;console.log(typeof a());// error : a is not defined 判断引用值的类型 1234567891011121314151617181920212223// 1. 分两类 原始值 引用值// 2. 区分引用值function type(target) &#123; var ret = typeof(target); var template = &#123; \"[object Array]\":\"array\", \"[object Object]\":\"object\", \"[object Number]\":\"number-object\", \"[object Boolean]\":\"boolean-object\", \"[object String]\":\"string-object\" &#125; if(target === null)&#123; return \"null\"; &#125; if(ret == \"object\")&#123; // 数组 对象 包装类（Object.prototype.toString） var str = Object.prototype.toString.call(target); return template[str]; &#125;else&#123; return ret; &#125;&#125; 数组去重 123456789101112Array.prototype.unique = function() &#123; var temp = &#123;&#125;, arr = [], len = this.length; for (var i = 0; i &lt; len; i ++) &#123; if(!temp[this[i]])&#123; temp[this[i]] = \"abc\"; arr.push(this[i]) &#125; &#125; return arr;&#125; 优化以下代码 123456789101112131415161718192021222324252627282930313233343536function getDay(day) &#123; switch(day) &#123; case 1 : document.write(\"Monday\"); break; case 2 : document.write(\"Tuesday\"); break; case 3 : document.write(\"Wednesday\"); break; case 4 : document.write(\"Thursday\"); break; case 5 : document.write(\"Friday\"); break; case 6 : document.write(\"Saturday\"); break; case 7 : document.write(\"Sunday\"); break; &#125;&#125;function retDay(day) &#123; var arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']; var ret = arr[day - 1]; if(ret === undefined) &#123; return 'error'; &#125;else &#123; return ret; &#125;&#125; retDay(7)","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://www.hsiliver.space/tags/数组/"},{"name":"类数组","slug":"类数组","permalink":"http://www.hsiliver.space/tags/类数组/"},{"name":"数组去重","slug":"数组去重","permalink":"http://www.hsiliver.space/tags/数组去重/"}]},{"title":"剖析this","slug":"this","date":"2019-07-08T13:57:58.000Z","updated":"2019-07-09T02:15:00.957Z","comments":true,"path":"2019/07/08/this/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/this/","excerpt":"","text":"剖析thisthis的指向有哪几种情况？this代表函数调用相关联的对象，通常页称之为执行上下文。 12345678910111. 作为函数直接调用，非严格模式下，this指向window，全局作用域的this指向window。严格模式下，this指向undefined。2. 函数预编译过程中，this指向window。3. 作为某对象的方法调用，this通常指向调用的对象。4. 使用apply、call、bind 可以绑定this的指向。5. 在构造函数中，this指向新创建的对象6. 箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。 如果对一个函数进行多次 bind，那么上下文会是什么呢？123let a = &#123;&#125;let fn = function () &#123; console.log(this) &#125;fn.bind().bind(a)() // =&gt; window 不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。 1234567// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() 多个this规则出现时，this最终指向哪里？首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，es6中箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 箭头函数 =&gt; 中this箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this 123456789101112131415161718192021222324var name = \"222\";var a = &#123; name : \"111\", say : function () &#123; console.log(this.name); &#125;&#125;var fun = a.say;fun(); // \"222\" 在全局window上执行a.say(); // \"111\"var b = &#123; name : \"333\", say : function (fun) &#123; fun(); // 没人调用，走预编译环节，在window执行 /* say : function () &#123; console.log(this.name); &#125;执行 */ &#125;&#125;b.say(a.say); // \"222\"b.say = a.say;b.say(); // \"333\" arguments在”use strict”中这俩家伙不让用 arguments.callee 1234567891011var test = function () &#123; console.log(arguments.callee) // ƒ () &#123;console.log(arguments.callee)&#125; // 指向函数自身引用&#125;var num = (function (n) &#123; if (n == 1) &#123; return 1; &#125; return n * arguments.callee(n - 1);&#125;(5)) fun.caller( 函数自己的属性 ) 12345678910111213141516// arguments上只有 callee 和length, symbol, __proto__ function test() &#123; demo(); console.log(arguments); // 如下图&#125;function demo() &#123; console.log(demo.caller);// demo 被调用的那个环境 /* 打印结果： ƒ test() &#123; demo(); console.log(arguments); &#125; */&#125;test(); 1234567891011121314151617181920212223242526272829303132333435363738394041421.var foo = \"123\";function print() &#123; var foo = \"456\"; this.foo = \"789\" console.log(foo);&#125;print(); // 456var foo = 123;function print() &#123; this.foo = 234; console.log(foo); console.log(this); // print &#123;foo: 234&#125;&#125;// print(); // 234new print(); // 123// var this = Object.creat(print.prototype); this里面没有foo属性var a = 5;function test() &#123; // var this = &#123; // 里面没a // __proto__ : test.prototype //&#125; a = 0; alert(a); alert(this.a); var a; alert(a);&#125;test();// 0 5 0new test(); // 0 undefined 0/*AO &#123; a : 0, this : &#123;&#125;&#125;*/ 2. 123456function print() &#123; console.log(foo);//undefined var foo = 2; console.log(foo);//2 console.log(hello);//报错：hello is not defined&#125; 3. 12345678function print() &#123; var test; // 被覆盖 test(); function test() &#123; console.log(1); &#125;&#125;print(); // 1 4 . 123456function print() &#123; var x = 1; if (x == \"1\") &#123;console.log(\"one\")&#125;; if (x === \"2\") &#123;console.log(\"two\")&#125;;&#125;print();//one 5. 1234567891011121314151617function print() &#123; var marty = &#123; name : \"marty\", printName : function () &#123;console.log(this.name)&#125; &#125; var test1 = &#123;name : \"test1\"&#125;; var test2 = &#123;name : \"test2\"&#125;; var test3 = &#123;name : \"test3\"&#125;; test3.printName = marty.printName; var printName2 = marty.printName.bind(&#123;name : 123&#125;); marty.printName.call(test1); // test1 marty.printName.apply(test2); // test2 marty.printName(); // marty printName2(); // 123 test3.printName(); // test3&#125;print(); 6 . 12345678910var bar = &#123;a : &quot;002&quot;&#125;;function print() &#123; bar.a = &apos;a&apos;; // 覆盖002 Object.prototype.b = &apos;b&apos;; return function inner() &#123; console.log(bar.a); console.log(bar.b); // 上原型链找 &#125;&#125;print()(); // a b 克隆 浅层 1234567891011121314var obj = &#123; name : 'abc', age : 123, sex : 'male'&#125;var obj1 = &#123;&#125;;function clone(origin, target) &#123; var target = target || &#123;&#125;; for (var prop in origin) &#123; target[prop] = origin[prop] &#125; return target;&#125;clone(obj, obj1); 深层(只考虑数组、对象) 12345678910111213141516171819202122232425262728293031323334353637383940var obj = &#123; name : \"huang\", age : 123, card : ['visa','master',123], wife : &#123; name : \"bcd\" son : &#123; name : 'faf' &#125; &#125;&#125;;var obj1 = &#123;&#125;;// 1遍历对象 for (var prop in obj)// 2判断是否原始值 typeof() object instanceof toString(万无一失) constructor// 3判断是数组还是对象// 4建立相应的数组和对象// 5递归function deepClone(origin, target) &#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = \"[object Array]\"; // \"[object Object]\" 反正俩个其中一个 // 1 for(var prop in origin)&#123; // 2 if(origin.hasOwnProperty(prop)) &#123; if(origin[prop] !== \"null\" &amp;&amp; typeof(origin[prop]) == 'object') &#123; target[prop] = toStr.call(origin[prop]) == arrStr ? [] : &#123;&#125;; deepClone(origin[prop],target[prop]); // 如果里面还有引用值，再来 // 引用值处理 &#125;else&#123; target[prop] = origin[prop]; // 原始值处理 &#125; &#125; &#125; return target;&#125;deepClone(obj, obj1) 三目运算符 1234567891011var num = 1 &gt; 0 ? (\"10\" &gt; \"9\" ? 1 : 0) : 2;if (1 &gt; 0) &#123; var = num; if (\"10\" &gt; \"9\") &#123; return num = 1 &#125;else &#123; return num = 0 &#125;&#125;else &#123; return num = 2&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"this","slug":"this","permalink":"http://www.hsiliver.space/tags/this/"},{"name":"克隆","slug":"克隆","permalink":"http://www.hsiliver.space/tags/克隆/"},{"name":"三目运算符","slug":"三目运算符","permalink":"http://www.hsiliver.space/tags/三目运算符/"},{"name":"arguments","slug":"arguments","permalink":"http://www.hsiliver.space/tags/arguments/"}]},{"title":"继承模式，命名空间，对象枚举","slug":"继承模式，命名空间","date":"2019-07-08T13:56:58.000Z","updated":"2019-07-09T02:11:25.090Z","comments":true,"path":"2019/07/08/继承模式，命名空间/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/继承模式，命名空间/","excerpt":"","text":"继承模式，命名空间，对象枚举继承模式 传统模式——&gt; 原型链（prototype） 过多的继承了没用的属性 借用构造函数（call / apply） 不能继承借用构造函数的原型 每次构造函数夺多走一个函数 共享原型（） 不能随意改动自己的原型 12345678910111213141516171819Father.prototype.lastname = \"huang\";function Father() &#123;&#125;function Son() &#123;&#125;Son.prototype = Father.prototypevar son = new Son();console.log(son.lastname); // huang// extend inherit（继承）// 封装继承方法Father.prototype.lastname = \"huang\";function Father() &#123;&#125;function Son() &#123;&#125;function inherit(Target, Origin) &#123; Target.prototype = Origin.prototype;&#125;inherit(Son, Father);// 这样不好，因为如果要给son单独添加一个属性的时候，将会同时给Father加上属性var son = new Son();// 于是就出现了圣杯模式 圣杯模式（加一个中介） 12345678910111213141516171819202122232425262728293031323334353637Father.prototype.lastname = \"huang\";function Father() &#123;&#125;function Son() &#123;&#125;function inherit(Target, Origin) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target;// *让constuctor指向目标对象 Target.prototype.uber = Origin.prototype; //*找到自己的超级父级，最终继承自谁&#125;inherit(Son, Father);var son = new Son();var father = new Father();Son.prototype.sex = \"male\";console.log(son.sex, father.ser); // male undefined/*我们还可以在丰满一下son.__proto__ --&gt; new F().__proto__ --&gt; Father.prototype让constuctor指向目标对象(如上面注释的有*两行)*/// 雅虎YUI3库的圣杯模式var inherit = (function () &#123; var F = function () &#123;&#125;; return function (Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;())// 闭包的第三作用：函数封装私有化/*F 被储存在return的函数的执行期上下文里面，被有私有化了（隐藏了），因为F是过度的函数，所以这个私有化是很好的*/ 命名空间 管理变量，防止污染全局，适用于模块化开发 12345678910111213// 闭包第四点：模块化开发，防止变量污染全局var name = 'hhh';var init = (function () &#123; // 约定俗成的初始化函数 'init' var name = 'abc'; // 里面的name与外边的name不会有任何关系 function callName() &#123; console.log(name); &#125; return function () &#123; callName(); &#125;&#125;()) jquery链式调用原理 12345678910111213141516var hobby = &#123; smoking : function () &#123; console.log('爽'); console.log(this); // hobby return this; &#125;, drinking : function () &#123; console.log('更爽'); return this; &#125;, perming : function () &#123; console.log('走烫头去'); return this; &#125;&#125;hobby.smoking().drinking().perming(); 属性的表示方法 1234567891011var obj = &#123;name : 'a'&#125;// 访问name属性： obj.name === obj['name'],// 事实上我们 obj.name 的时候 系统会隐式调用 obj['name']var hobby = &#123; hobby1 : '喝酒', hobby2 : '烫头', hobby3 : '抽烟' hobbyFun : function (num) &#123; return this['hobby' + num] &#125;&#125; 对象的枚举（遍历）enumeration for in（for循环的简化版，对象有多少个属性，就循环多少圈） 12345678910111213var obj = &#123; name : 'hsz', age : 20, sex : 'male', height : 170, weight : 55&#125;for (var prop in obj) &#123; console.log(prop); // name age sex height weight(打印对象的属性名) console.log(obj.prop); // 打印对象的属性值？ 结果是undefined // 因为会隐式的调用obj['prop']而不是obj[prop] console.log(obj[prop]);// 打印对象的属性值&#125; hasOwnProperty 1234567891011121314151617181920212223242526272829var obj = &#123; name : 'hsz', age : 20, sex : 'male', height : 170, weight : 55 __proto__ : &#123; lastName : 'h' __proto__ : Object.prototype &#125;&#125;for (var prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; // 一般这俩是成套存在的 /* 判断是否是自己的属性或者方法（排除原型），但是一旦到了Object.prototype, 就会放弃遍历了 */ console.log(obj[prop]); &#125; console.log(obj[prop]); /* 但是要注意，但凡是自己设置的属性，prop到哪都能给你遍历出来 比如 Object.prototype.abc = 'abc', 照样给你遍历出来， 但凡是系统自带的就遍历不出来 */ &#125; in 12// in 只能判断 能不能够访问到这个属性，不管这个属性在哪'height' in obj // 控制台中返回true instanceof A instanceof B 官方解释： A 对象是不是 B 构造函数构造出来的 真正的判断： *A 对象的原型链上** 有没有 B的原型 1234function Person() &#123;&#125;var person = new Person();console.log([] instanceof Array); // trueconsole.log(person instanceof Array); // false 123456789101112131 typeof 123; // \"number\"2 typeof function () &#123;&#125; // \"function\"3 typeof undefined; // \"undefined\"4 typeof &#123;&#125;; //\"object\"typeof null; //\"object\"typeof []; //\"object\"5 typeof true; // \"boolean\"6 typeof '123'; // \"string\" 123456789var x = 1;if (function f() &#123;&#125;) &#123; // （）会把function f() &#123;&#125; 变成表达式然后函数名 f 失去效用 x += typeof f;&#125;console.log(x); // \"1undefined\"parseInt('1a') == 1 // truetypeof parseInt('1a') // \"number\"","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"继承模式","slug":"继承模式","permalink":"http://www.hsiliver.space/tags/继承模式/"},{"name":"对象枚举","slug":"对象枚举","permalink":"http://www.hsiliver.space/tags/对象枚举/"},{"name":"圣杯模式","slug":"圣杯模式","permalink":"http://www.hsiliver.space/tags/圣杯模式/"}]},{"title":"call和apply实现","slug":"call-apply","date":"2019-07-08T13:55:58.000Z","updated":"2019-07-09T02:19:17.617Z","comments":true,"path":"2019/07/08/call-apply/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/call-apply/","excerpt":"","text":"call和apply实现 相同点：*call 和apply *改变this指向 差异： 传参列表不同 call 需要把实参按照形参的个数传进去 apply 需要传一个arguments 优点：借用别人的工厂生产函数 12345678910111213141516171819202122// call的第一个参数是要改变的目标function Person1(name) &#123; this.name = name&#125;var obj = &#123;&#125;;person1.call(obj, \"hsz\"); // this就指向了objconsole.log(obj); // &#123;name: \"hsz\"&#125;function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, tel, grade) &#123; // var this = &#123;&#125;; 自己隐式地生成 Person.call(this, name, age, sex); // 借用别人的函数，实现自己的功能 // 再增加自己想要的属性、方法 this.tel = tel; this.grade = grade;&#125;var student = new Srudent(\"hsz\", 123, \"male\", 139, 2019) call12345678910Function.prototype.newCall = function () &#123; var ctx = arguments[0] || window; ctx.fn = this; var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(`arguments[$&#123;i&#125;]`) &#125; return result = eval(`ctx.fn($&#123;args.join(',')&#125;)`); delete ctx.fn;&#125; eval();——会改变作用域，不好，但是这里为了实现 call功能，并没有其他影响join() 方法用于把数组中的所有元素放入一个字符串 apply123456789101112131415Function.prototype.newApply = function (ctx, arr) &#123; var ctx = ctx || window; ctx.fn = this; if (!arr) &#123; return result = ctx.fn(); delete ctx.fn; &#125;else &#123; var args = []; for (var i = 0; i &lt; arr.length; i++) &#123; args.push(`arr[$&#123;i&#125;]`) &#125; return result = eval(`ctx.fn($&#123;args.join(',')&#125;)`); delete ctx.fn; &#125;&#125;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"call","slug":"call","permalink":"http://www.hsiliver.space/tags/call/"},{"name":"apply","slug":"apply","permalink":"http://www.hsiliver.space/tags/apply/"}]},{"title":"原型，原型链","slug":"原型，原型链","date":"2019-07-08T13:54:58.000Z","updated":"2019-07-09T02:09:26.213Z","comments":true,"path":"2019/07/08/原型，原型链/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/原型，原型链/","excerpt":"","text":"原型 定义： 原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。(类似遗传) obj.prototype ———— 原型 123456Person.prototype.name = \"hsz\";function Person() &#123; &#125;var person1 = new Person();console.log(person1.name); // \"hsz\" 利用原型特点和概念，可以提取共有属性。 1234567891011121314151617Car.prototype.name = \"BMW\";Car.prototype.height = 1400;Car.prototype.lang = 4900;// 这样的目的是消除代码耦合， 因为如果我new的次数多了，就会造成耦合度很高function Car(owner, color) &#123; this.owner = owner; this.color = color&#125;var car = new Car('red', 'prof.huang');car.name = 'zjx'; // Car &#123;owner: \"red\", color: \"prof.huang\", name: \"zjx\"&#125;// 想要改变原型链上的name属性只有 Car.prototype.name = \"zjx\";// 通过后代是改不了祖先的属性的// 增加属性也是要通过prototype// 删除属性： delate， 如果要删除祖先的属性一样要通过prototype去删除 对象如何查看原型 ——&gt; 隐式属性 __ proto __ 123456789101112131415161718// 尽量别修改的属性Person.prototype.name = 'abc';function Person() &#123; /* 每一个对象都有一个proto指向本身的prototype 比如找一个属性，如果自身找不到的话就会沿着__proto__ 的指向找 var this = &#123; __proto__ : Person.prototype &#125; 这个__proto__ 也是可以修改的 */ &#125;var obj = &#123;name : \"happy\"&#125;var person = new Person();person.__proto__ = obj;// 这是后person.__proto__ 就指向了 obj 而不是 Person 对象如何查看对象的构造函数 ——&gt; constructor 12345678910111213141516171819202122232425function Car(owner, color) &#123; this.owner = owner; this.color = color&#125;var car2 = new Car();Car.prototype.constructorcar2.constructor// 控制台中是这样的ƒ Car(owner, color) &#123; this.owner = owner; this.color = color&#125;// 这个constructor是可以人为改变的function Person() &#123;&#125;Car.prototype = &#123; constructor : Person&#125;var car2 = new Car();car2.constructor// 控制台中是这样的ƒ Person() &#123;&#125; 脑经急转弯 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Person.prototype.name = 'happy';function Person() &#123; // var this = &#123;__proto__ : Person.prototype&#125; // 现在__proto__ 和 Person.prototype 指向一个空间; // 即使 Person.prototype 指向了另一个空间, __proto__ 依然指向 \"happy\"&#125;var person = new Person();console.log(person.name); // happyPerson.prototype.name = 'hsz' // 覆盖了原来的namePerson.prototype = &#123; name : 'xiuxiu' // 这相当于存到了另一个堆里面，相当于换血了 /* 同理如下： var obj = &#123;name : \"a\"&#125;; var obj1 = obj; obj = &#123;name : \"b\"&#125; obj1.name == \"a\" obj.name == \"b\" obj1 ==&gt; obj ==&gt; name: \"a\" 然后：obj1 ==&gt; name : \"a\", obj ==&gt; name : \"b\" __proto__ ==&gt; Person.prototype ==&gt; \"hsz\" 同理然后：__proto__ ==&gt; \"hsz\", Person.prototype ==&gt; \"xiuxiu\" */&#125;console.log(person.name); // hsz// 那么我们再来看另一种情况Person.prototype.name = 'happy';function Person2() &#123;&#125;Person.prototype = &#123; name : 'xiuxiu'&#125;var person2 = new Person2();console.log(person2.name); // xiuxiu/*这就需要考虑预编译环节了 function Person2() &#123;&#125; 首先函数声明提升 Person.prototype.name = 'happy'; 然后执行这一句 Person.prototype = &#123; name : 'xiuxiu' 然后执行这一句 &#125; var person2 = new Person2(); 当new的时候，函数才发生改变，这个时候name已经被覆盖了 上一次是应为函数已经new了，才改变name的，所以两次结果不一样。顺序有时候也很关键*/ 原型链 原型链的连接点就是 __ proto__ 原型链的访问方式跟作用域链的访问方式雷同，都是先往内部找，找不到再找远处 1234567Grand.prototype.name = \"hsz\"function Grand() &#123;&#125;var grand = new Grand();/*Grand.prototype.__proto__ = Object.prototypeObject.prototype 是所有原型链的终端*/ 原型链上的增、删、改、查 只能通过自己增、删、改、查，后代是无法进行这些操作的 1234567891011121314151617Person.prototype = &#123; name : \"a\", num : 10, sayname : function () &#123; console.log(this.name); &#125;&#125;function Person() &#123; this.name = \"b\";&#125;var person = new Person();person.num++/*当调用person.num++后，就有了num属性Person &#123;name: \"b\", num: 12&#125;就像复制了一样，后面会说克隆，有异曲同工的效果*/ Object.create(原型)——更加灵活的创建对象的方法 1234567var obj = &#123;name : \"hsz\", age : 123&#125;;var obj1 = Object.create(obj);Person.prototype.name = \"hsz\";function Person() &#123;&#125;var person = Object.create(Person.prototype); 绝大多数的对象的最终都会继承自Object.prototype 1234567var obj = Object.create(null); // 这个就没原型 only object and null// 即使人为的加了__proto__, 系统一样读不了obj.__proto__ = &#123;name : \"hsz\"&#125;console.log(obj.name); // undefined// undefined and null 没有原型所以 .toString(); 会报错123.toString(); // 报错，因为 123. 会被系统认为是浮点型 1234567891011121314151617181920212223242526var num = 123;num.toStrng(); // \"123\"// 在Number的prototype上有很多方法其中有toStringNumber.prototype.toString = function () &#123; // 这就叫方法的重写 // 所以事实上我们调用的是Number.prototype上它自己重写的toString方法&#125;// 如果我们调用的是Object.prototype.toString方法的话，结果就不是\"123\"了Object.prototype.toString.call(123); // \"[Object Number]\"var obj = &#123;&#125;;obj.toString(); // \"[object Object]\"var obj1 = Object.create(null);document.write(obj); // 报错// 事实上我们打印的是这个： document.write(obj.toString()),// 下面我们来验证是否真的调用了toString方法var obj1 = Object.create(null);obj1.toString = function () &#123; return \"哈哈哈\"&#125;document.write(obj1); // \"哈哈哈\" 小bug 12345javascript的小数多少有些偏差0.14 * 100 // 14.000000000000002// 所以尽量别用toFix()// 小数点后可以操作18位以上了，已经会用科学计数法表示了// 可以正常计算的范围内： 小数点前16位，后16位 是可以计算准确的","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"原型","slug":"原型","permalink":"http://www.hsiliver.space/tags/原型/"},{"name":"原型链","slug":"原型链","permalink":"http://www.hsiliver.space/tags/原型链/"}]},{"title":"对象_包装类","slug":"对象_包装类","date":"2019-07-08T13:53:58.000Z","updated":"2019-07-09T02:13:05.342Z","comments":true,"path":"2019/07/08/对象_包装类/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/对象_包装类/","excerpt":"","text":"对象、包装类 对象可以放属性，函数，需要设置属性名，属性值 12345678910111213141516var hsz = &#123; name: \"hsz\", age: 23, sex: \"male\", smoke: function () &#123; console.log(\"cool!!!\"); this.health --; &#125;, drink: function () &#123; console.log(\"so cool!!\"); this.health ++; &#125;, health: 100&#125;// 这里的函数与普通的函数一样可以传参数等操作// 如果把一个对象当成一个人的话，health 会称为这个人的健康（this），而不是hsz的health 属性的增、删、改、查123456hsz.girlFriend = \"xiangZhang\"; // 增hsz.girlFriend; // 查hsz.girlFriend = \"xiuxiu\" // 改delate hsz.health // 删// 当一个变量未声明就输出会报错，但是一个对象里的属性没添加，不会报错，打印undefined 对象的创建方法 var obj = {} plainObject 对象字面量、对象直接量 构造函数 1) 系统自带构造函数 Object() 123var obj = new Objectvar obj = &#123;&#125;// 这两者是没有任何区别的，除了视觉上 2) 自定义( 构造函数 ) 1234567891011121314151617181920/* 由于函数与构造函数视觉上没有区别，为了小伙伴们更好的区分，就产生了大驼峰式命名即首字母大写*/function Car(color) &#123; this.color = color, // 通过参数改变颜色，让构造函数变得更强大 this.name = \"BMW\", this.height = \"1400\", this.lang = \"4900\", this.width = 1000, this.health = 100, this.run = function () &#123; this.health --; &#125; // 将所有需要批量制造的事物定义好，&#125;// 但是必须借助一个工具 newvar car1 = new Car('red'); // 这就生产出来了一辆与 原始Car 一样的 car1 了car.name = \"Maserati\" // 然后再改变成自己想要的 玛莎拉蒂 123456789101112131415161718192021function Student(name, age) &#123; /* 1.在new的过程中，内部会隐式地： var this = &#123; &#125;; 2.往this这个对象添加属性 this = &#123; name: \"\", age: &#125; */ this.name = name, this.age = age /* 3.最后： return this; 只能return 一个对象，其他的都不行 */&#125;var student = new Student('hsz', 18) ### 包装类 1234var num = new Number(123); // Number 型对象var str = new String('abc'); // String 型对象var bol = new Boolean('true') // Boolean 型对象 // 事实上也就是个对象 ##### 原始值是坚决不能有属性和方法的，但是为什么这种操作，又不报错呢 123456789101112var num = 4;/*(隐式地) new Number(4)（然后） Number(4).len = 3(再然后) delate —— 销毁 new Number(4).len = 3;(再然后) new Number(4).len ———— 这是一个系统给你新new的Number(最后打印) undefined*/num.len = 3;console.log(num.len); // undefinedconsole.log(num); // 4 —— num依然存在，销毁的不是num ##### 我们再来看这个特殊的家伙 123456789101112var str = 'abcd';str.length = 2;console.log(str); // 'abcd'console.log(str.length); // 4 ———— 蒙了吧/*(隐式地) new String('abcd')（然后） String('abcd').len = 3(再然后) delate —— 销毁 new String('abcd').len = 3;(最后打印) str == 'abcd', str.length == 4;new String('abcd').length 是系统自带的 ———— 这是一个很特殊的*/ ##### Boolean 和 string new 完了后可以像object一样添加自己的属性 1234567891011var str = new String('abcd');str.a = 'bcd';str.b = function () &#123; console.log(this.a) &#125;console.log(str) // String &#123;\"abcd\", a: \"bcd\", b: ƒ&#125;console.log(str.length) // 4var boo = new Boolean('abcd');boo.a = 'bcd';boo.b = function () &#123; console.log(this.a) &#125;console.log(boo); //Boolean &#123;true, a: \"bcd\", b: ƒ&#125;console.log(Boolean.length) // 1 ##### 例子 12345678var str = \"abc\";str += 1; // \"abc1\"var test = typeof(str); // \"string\"if (test.length == 6) &#123; test.sign = \"typeof的返回结果可能是String\"&#125;console.log(test.sign);// undefined// 这出题人真会折磨人 1234567891011var x = 1, y = z = 0;function add(n) &#123; return n = n + 1;&#125;y = add (x);function add(n) &#123; return n = n + 1;&#125;z = add(x)// x = 1, y = 4, z = 4; // 函数声明提升， add覆盖（视觉上懵人） Object.create() 1var a = Object.create(null) // 返回为null的空对象，啥都没有 除此之外，没啥区别了","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"对象","slug":"对象","permalink":"http://www.hsiliver.space/tags/对象/"},{"name":"包装类","slug":"包装类","permalink":"http://www.hsiliver.space/tags/包装类/"}]},{"title":"函数_作用域链","slug":"函数_作用域链","date":"2019-07-08T08:18:49.000Z","updated":"2019-07-09T02:12:31.094Z","comments":true,"path":"2019/07/08/函数_作用域链/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/函数_作用域链/","excerpt":"","text":"函数作用域链 函数函数声明高内聚， 低耦合 命名规范：小驼峰式命名 123451. 命名函数表达式function theFirstFun() &#123; console.log('abc');&#125;theFirstFun.name // theFirstFun ​ 表达式类函数，忽略函数名, 此时 abc 被忽略 1234562. 匿名函数表达式 ———— 后来叫做函数表达式var test = function abc() &#123; console.log('abc')&#125;test();test.name // abc 函数传参 12345678910111213141516171819202122232425262728293031323334// 形参 ———— delete 删除不了function sum(a, b) &#123; console.log(sum.length) // 2 形参长度 console.log(arguments.length) // 3 实参长度 // 等同于在函数内部声明了 a, b var c = a + b; coonsole.log(c) // 每个函数在出生的时候系统就会隐式地创建一个arguments（类数组）来装实参——实参列表&#125;// 实参sum(1, 2, 3)function sum1(a, b, c) &#123; // 现在的情况是 // var a = 1; // var b = 2; // var c; // arguments =&gt; [1, 2] 实参只有 2 位 // 然后我们改变规则 a = 10; console.log(arguments[0]); // 10 // 我们再改变一次 arguments[0] = 20; console.log(a); // 20 // 我们会发现这中间存在映射规则 实参的每一位对应形参的每一位 c = 30; console.log(arguments[2]); // undifined; // 所以得出 实参出生的时候有几个 就是几个&#125;sum1(1, 2); 函数的 return 值函数的结束条件 + 返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function sum(a) &#123; console.log(a); return '123'; // 有中断 并且 返回值 结束的功能, 不会打印下面的20 console.log(20); // 2 &#125;sum(2);// 123 倒叙且变中文function reverse() &#123; var num = window.prompt('input'); var str = \"\"; for (var i = num.length - 1; i &gt;= 0; i --) &#123; // 倒着加 2 =》 1 =》 0 str += transfer(num[i]); &#125; console.log(str);&#125;function transfer(target) &#123; switch (target) &#123; case \"1\": return \"壹\"； case \"2\": return \"俩\" case \"3\": return \"仨\" &#125;&#125;// 阶乘// 递归 —— 唯一好处，简洁代码function jc(n) &#123; if (n == 1 || n == 0) &#123; return 1; // 出口， 不然就在无穷死循环 &#125; return n * jc(n-1)&#125;// 1. 找规律// 2. 找出口// 斐波那契数列 fn(n) == fb(n - 1) + fb(n -2)function fb(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125; 作用域初探JS运行分三步：语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。 全局变量：在函数外声明的变量 局部变量：在一个区域内声明的变量预编译 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量归全局所有。 a = 123; 一切声明的全局变量，全是window的属性。window就是全局的域 1234var a = 123;console.log(window.a); // 123// 等同于：window &#123;a : 123&#125; 函数预编译四部曲 123456789101112131415fn(1);function fn() &#123;console.log(a); // ƒ a() &#123;&#125; var a = 123; // 提升到第 2 位 覆盖第一个 a console.log(a); // 123 function a() &#123;&#125;; // 提升到第 1 位 console.log(a); // 123 var b = function () &#123;&#125;// 提升到第 2 位 console.log(b); // ƒ () &#123;&#125; function d() &#123;&#125; // 提升到第 1 位&#125; 创建AO对象 (action object 由于这个函数而产生的存储空间库) 1AO &#123;&#125; 找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined 12345678AO &#123; // arguments : [1], // this : window, // 这里还有两步，这里为了方便，先注释，不考虑。 a : undefined, b : undefined,&#125; 将实参值和形参统一 12345AO &#123; a: 1, b: function () &#123;&#125;, // 形参没有对应的实参就不用管&#125; 在函数体里面找函数声明， 值赋予函数体 *（函数表达式提升不了，它是表达式） 123456789101112AO &#123; a: function a() &#123;&#125;,// 覆盖了形参的a b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;=====&gt;AO &#123; a: 123, // 执行完第一个console.log后，a再度覆盖fn b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;// 一句一句执行 例子2： 12345678910111213141516171819202122232425262728293031323334353637383940function test(a, b) &#123; console.log(a); c = 0; var c; a = 3; b = 2; console.log(b); function b() &#123;&#125; function d() &#123;&#125; console.log(b);&#125;test(1);/*1. AO &#123;&#125;2. AO &#123; a: undefined, b: undefined,&#125;3. AO &#123; a: 1, b: undefined,&#125;4. AO &#123; a: 1, b: function b() &#123;&#125;, d: function d() &#123;&#125;&#125;所以第一个console.log(a) =&gt; 1然后继续AO &#123; a: 3, b: 2, c: 0, d: function d() &#123;&#125;&#125;所以后面两个console.log(b) 都是 2*/(window.foo || (window.foo = 'bar'));// bar 全局：global object( GO ) GO === window 作用域，作用域链函数作用域[[scope]] [[scope]] : 每个javascript函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供javascript引擎存取，[[scope]] 就是其中一个。[[scope]] 指的就是函数的作用域，其中存储了执行期上下文的集合。 执行期上下文： 当函数执行前一刻，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。 作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们称这种链式链接为作用域链。查找变量时，要从作用域链的顶部开始查找。Activation Object（AO）到Global Object（GO）。 查找变量： 从作用域链的顶端依次向下查找 1234567891011121314151617181920function a() &#123; function b() &#123; var bb =234; &#125; var aa = 123; b();&#125;var glob = 100;a();// a defined(定义) a.[[scope]] --&gt; 0 : GO// a doing(执行) a.[[scope]] --&gt; 0 : a-AO// 1 : GO// b defined(定义) b.[[scope]] --&gt; 0 : a-AO// 1 : GO// b doing(执行) b.[[scope]] --&gt; 0 : b-AO// 1 : a-AO// 2 : GO 闭包1 当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。 危害：闭包会导致原有作用于连不释放，造成内存泄漏（占的多了，剩的就少了） 闭包问题的解决方法：立即执行函数、let 详细解释： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO），执行期上下文定义了一个函数执行时的环境。 函数还会获得它所在作用域的作用域链，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。 函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。 但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。 1234567891011121314151617function a() &#123; function b() &#123; var bbb = 234; console.log(aaa); &#125; var aaa = 123; return b;&#125;var glob = 100;var demo = a();demo(); // 123/*f b() &#123;&#125; 被保存出来了并且赋给了demo虽然return后 a 的执行期上下文被销毁，但是b函数[[scope]]=&gt; aAO, bAO, GO所以顺着链找就可以找到 ‘var aaa = 123;'*/ 12345678910111213141516// 闭包作用于累加function a() &#123; var num = 100; function b() &#123; num ++; console.log(num); &#125; return b;&#125;var demo = a();demo(); // 101demo(); // 102/*第二个为啥是102 呢？第一次demo执行完了后，a的AO依然被销毁，但是b的[[scope]]里面存的是第一次demo();后的aAO，事实上就是a斩断了aAO的线，想要销毁，但是b的手里撰着aAO，所以第一次执行产生的aAO，GO被永远当成了基础来用了;*/ 1234567891011121314151617// 闭包作用于缓存（储存结构）function test() &#123; var num = 100; function a() &#123; num ++; cosole.log(num); &#125; function b() &#123; num --; console.log(num); &#125; return [a, b];&#125;var myArr = test();myArr[0](); // 101myArr[1](); // 100// 被保存出来的f a() &#123;&#125; 和 f b() &#123;&#125; 共用一个testAO 立即执行函数 函数出生的时候都是等待被执行的，这个过程是很占内存的，尤其是那些只被执行一次就销毁的函数, 所以有了立即执行函数，执行完就被销毁，这是跟普通函数的唯一区别，其他一样，有执行期上下文，可以传参等等 针对初始化功能的函数 1234567891011121314(function () &#123;&#125;()); // W3C 建议第一种(function () &#123;&#125;)();var test = function () &#123; console.log(123);&#125;();+ function test() &#123;&#125;();- function test() &#123;&#125;();! function test() &#123;&#125;();// 陷阱function test(a, b, c, d) &#123; console.log(a, b, c, d)&#125;(1, 2, 3, 4);// 比报错也不执行 闭包2 针对for循环 123456789101112131415161718function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + \" \"); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;// 10个10/*我们只看第一个for循环， 因为第二个只是为了执行在for循环中 i 是不停在变的，我们要知道，函数只有在执行的时候才会被读取语句，当return完的时候，test函数才执行结束，而此时所有return出来的函数用的都是 test的AO，并且这个testAO里面for循环出来的i已经变成 10 了，当我们执行 myArr 的时候，用的就是 i = 10*/ 解决办法 1234567891011121314// (es6) letfunction test() &#123; var arr = []; for (let i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + \" \"); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125; 1234567891011121314151617181920212223242526272829303132333435function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; (function (j) &#123; arr[j] = function () &#123; document.write(j + \" \"); &#125; &#125;(i)) &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;/*在for循环中：(function (0) &#123; // j = 0 arr[0] = function () &#123; document.write(j + \" \"); &#125;&#125;(0)) // ———— 马上执行，然后将arr[0]丢到test的arr里面，等待被return出去,// 此时立即执行函数的AO依然被arr[0]这个函数保存在arr[0]的[[scope]]里 (function (1) &#123; // j = 1 arr[1] = function () &#123; document.write(j + \" \"); &#125;&#125;(1)) // ———— 马上执行，然后将arr[1]丢到test的arr里面，等待被return出去................*/ 1234567891011121314151617181920212223function test () &#123; var food = \"apple\"; var obj = &#123; eatFood : function () &#123; if (food != \"\") &#123; console.log(\"I am eating \" + food); food = \"\"; &#125;else &#123; console.log(\"There is nothing!\"); &#125; &#125;, pushFood: function (myFood) &#123; food = myFood &#125; &#125; return obj;&#125;var person = test();person.eatFood(); // I am eating appleperson.eatFood(); // There is nothing!person.pushFood('banana'); person.eatFood(); // I am eating banana// 大家保存的都是同一个域，所以公用food这个变量（缓存） 12345678910111213141516171819202122&lt;!-- 阿里巴巴uc事业社招笔试题 --&gt;&lt;!--使用原生js，addEventListener，给每个li元素绑定一个click事件，输出他们的顺序--&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function () &#123; var ulList = document.getElementsByTagName('ul')[0]; var liList = ulList.getElementsByTagName('li'); for (var i = 0; i &lt; liList.length; i++) &#123; (function (j) &#123; liList[j].addEventListener('click', function (j) &#123; console.log(j) &#125;) &#125;(i)) &#125; &#125; // 同样可以用let解决&lt;/script&gt; 1234567891011121314151617/* 腾讯微店写一个方法，求一个字符串的字节长度提示： charCodeAt(); 一个中文占两个字节, 一个英文占两个字节, charCodeAt()方法可返回置顶位置的字符得到Unicode编码，这个返回值是0-65535之间的整数当返回值是 &lt;= 255时为英文（占1个字节）, 当返回值 &gt; 255 时为中文（占2个字节）*/ function retByteslen(target) &#123; var count, len; count = len = target.length; for (var i = 0; i &lt; len; i++) &#123; if (target.charCodeAt(i) &gt; 255) &#123; count ++; &#125; &#125; console.log(count);&#125; 逗号表达式 12345678910111213141516171819202122232425var a = (1 - 1, 1 + 1, 2 + 5);console.log(a); // 7// 一定要用括号括起来， 括号里面需要计算的先计算，，最后返回最后一个的计算结果var f = (function f() &#123; return \"1\"; &#125;,function g() &#123; return 2 &#125;)();console.log(typeof(f)) // numbervar x = 1;if (function f() &#123;&#125;) &#123; // (function f() &#123;&#125;) ==&gt; 被括号变成了表达式，函数名被忽略了 x += typeof f;&#125;console.log(x); // \"1undefined\"// 阿里巴巴UC社招笔试题： body 插入 一个div（原生js）var oDiv = document.createElement('div');var body = document.getElementsByTagName('body')[0];body.appendChild(oDiv);","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"函数","slug":"函数","permalink":"http://www.hsiliver.space/tags/函数/"},{"name":"预编译","slug":"预编译","permalink":"http://www.hsiliver.space/tags/预编译/"},{"name":"作用域链","slug":"作用域链","permalink":"http://www.hsiliver.space/tags/作用域链/"},{"name":"闭包","slug":"闭包","permalink":"http://www.hsiliver.space/tags/闭包/"}]},{"title":"js简介","slug":"js简介","date":"2019-07-08T06:45:09.000Z","updated":"2019-07-09T02:17:34.024Z","comments":true,"path":"2019/07/08/js简介/","link":"","permalink":"http://www.hsiliver.space/2019/07/08/js简介/","excerpt":"","text":"js —— Javascript：解释性语言 js ——JavaScript：解释性语言同时也叫 ECMAScript 编译 C，C++等 ​ 优点：快 ​ 不足：移植性不好，(不跨平台) 解释 javascrip， php等 ​ 优点：跨平台（不需要编译成文件） ​ 不足：稍慢 混合型 Java ​ .java –&gt;javac –&gt; 编译 –&gt; .class —-&gt; jvm —-&gt; 解释执行（两个都不是） 生活中的异步就是js的同步 单线程，同一时间处理一件事 那是怎么模拟成多线程呢？处理事件足够快的情况下，就可以做到看起来同时在做同一时间在做多件事 专业术语： 轮转时间片（争抢时间） 主流浏览器： ​ IE —————— trident ​ Chrom ———— webkit / blink ​ Firefox ———— Gecko ​ Opera ———— presto ​ Safari ———— webkit 引入js ​ 页面嵌入&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; ​ 外部js文件&lt;script type=&quot;text/javascript&quot; src=&quot;./***.js&quot;&gt;&lt;/script&gt; ​ 为符合W3C标准 结构(html) 行为(js) 样式(css) 相分离 ​ 编程语言特点： 有变量( variable ) ​ html，css属于脚本语言，计算机语言( 依然不影响它们的强大 ) 变量声明 ​ var a;—— 向window申请一个地方叫a ​ 多个变量时尽量单一 var 123var a, b, c; 变量赋值 ​ a = 100;—— 把100给a ​ 再次赋值111给 a ，则原来100会被替换 变量命名规则 变量名必须以包括 英文字母，_ , $ 开头 变量名可以包括 英文字母， _ , $ 数字 不可以用系统关键字(var new break else等)， 保留字作为变量名 (float int long class等) 运算优先级 &gt; 赋值 值的类型 原始值 （stack）栈内存 first in, last out （不可改变性） ​ Number ———— 数字（1, 2, 3, 4） ​ Boolean ———— 布尔（true / false） ​ String ————— 字符串（’ 123 ‘， “ 123 “） ​ undefined ——— 没有定义的（undefined） ​ null —————— 空—–占位（null） 引用值（heap）堆内存 ​ Array ————— 数组（[1, 2, 3, 4]） ​ Object ———— 对象（{a: 1, b: 2}） ​ function ——— 函数（function () {}） ​ Data ————— Data（） ​ RegExp ———— 正则（//） Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中; 栈内存与栈内存之间是复制的关系var b = a; 12345678var num = 100;var num1 = num;num = 200；事实上 —— 100 依然存在，只是剪断了 num 与 100 的关系然后重新在 window 弄了个 num1 再然后将原来的 num值（100）赋给 num1，最后又重新找window要了个地方叫num，将原来的num地方抹去变量名，再把200赋值给num Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量（地址）储存在栈中，通过指针（这个地址）指向储存在堆中的实际对象 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。 Boolean 如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。 Date 返回日期的文字表示法。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] } Number 返回数字的文字表示。 String 返回 String 对象的值。 默认 返回 “[object objectname]”，其中 objectname 是对象类型的名称。 123var arr = [1, 2];var arr1 = arr;arr.push(3); 123var arr = [1, 2];var arr1 = arr;arr = [1, 3]; js语句基本规则 语句后面加分号结束 “ ; “ js语法错误会引发后续代码终止，但不会影响其他js代码块 低级错误：（语法解析错误）出现中文符号等 逻辑错误：（标准错误， 情有可原）没有定义变量等 一个&lt;script type=&quot;text/javascript&quot;&gt;&lt;script/&gt;就是一个js代码块 书写格式要规范， “ = + / - “ 两遍呢都应该有空格 运算操作符 数学运算，字符串连接 任何数据类型加字符串都等于字符串 “ + “ , “ - “ , “ * “, “ / “ , “ % “ , “ () “ 优先级 “ = “ 最弱， “ () “ 最强 “ ++ “ , “ – “ , “ += “ , “-=” , “ /=” , “ *= “, “ %= “ 1234567891011121314151617181920212223242526272829303132// a++ ——&gt; a = a + 1var a = 10;console.log( a++ ); // 先打印a，再 ++ 10var b = 20;console.log( ++b ); // 先 ++ ，再打印a 21var num1 = 10;var num2 = ++num1 - 1 + num1++; // 但是工作这样写是不行的，要新人都可以看懂才好console.log(num2 + ' ' + num1); // 21 12 // num += 10; ——&gt; num = num + 10// 交换 n 和 m 的值var n = 123;var m = 234;1. var c = n; n = m; m = c;2. a = a + b; b = a - b; a = a - b;3. var a = 1 + 'a'; // 1a var b = 0 / 0; // NaN var c = 1 / 0; // infinity4. var a = 1; var b = ++a + 1; // 3 '++'第一运算 var c = a++ + 1; // 2 '++'最后才运算 比较运算符 “ &lt; “ , “ &gt; “ , “ = “ , “ &gt;= “ , “ &lt;= “ , “==” , “ != “ , “ === “ 字符串比较的是 ASCLL 码 123456var a = '10' &gt; '8'; // false&#123;&#125; == &#123;&#125;; // false[] == []; // falsenull == undefined; // true 逻辑运算符 “ &amp;&amp; “ , “ || “ , “ !“ —— 运算的结果为真实值 “ &amp;&amp; “ —— 表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就返回表达式的值了，简单来说：遇到为false的值返回 这个值，遇到全为true的值就返回 最后一个值, 有中断的作用，所以可以作为”如果，那么”: 12 &gt; 1 &amp;&amp; document.write('aaa') “ || “ —— 遇到为true的值返回 这个值，遇到全为false的值就返回 最后一个值 “! “ —— 转换为布尔值再取反， !!NaN转换为布尔值, 调用Boolean() undefined, null, NaN, “”, 0 —— 这五个值返回的布尔值都是FALSE 条件语句循环语句 if语句 —— 括号里的条件为true就运行 “{}” 里面的 1234567891011if (1 &gt; 0 &amp;&amp; 2 &gt; 0) &#123; console.log('a');&#125;if () &#123; &#125;else if () &#123; // 类似排除法 &#125;else &#123; &#125; for循环 12345678910111213141516171819202122232425262728for ( var i = 0; i &lt; 10; i++ ) &#123; // (1) —————（2）—————（3） // 减少我们的重复 console.log('a') // 打印10个a&#125;/* for 循环执行顺序： 先执行一遍（1） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 直到（2）有一次条件不成立，立马停止1. var i = 0;2. if (i &lt; 10) &#123; console.log('a')&#125;3. i++; ---&gt; i = 1;4. if (i &lt; 10) &#123; console.log('a')&#125;5. …………*/ while循环（简化版的for循环） 123456789101112var i = 0;/*for (;i &lt; 10;) &#123; console.log(i); i++;&#125;*/while (i &lt; 10) &#123; console.log(i); i++;&#125;// 两个一样的效果 练习： 计算2的n次幂，n可输入，n为自然数 1234567var n = parseInt(window.prompt('input'));var mul = 1;for (var i = 0; i &lt; n; i ++) &#123; mul *= 2;&#125;console.log(mul)// 先找规律，在写 计算n的阶乘，n可输入 1234567var n = parseInt(window.prompt('input'));// parseInt() 函数可解析一个字符串，并返回一个整数。var mul = 1;for (var i = 1; i &lt;= n; i ++) &#123; mul *= i;&#125;console.log(mul); 著名的斐波那契数列， 输出第n项 1234567891011121314var n = parseInt(window.prompt('input'));var first = 1, secend = 2, third;if (n &gt; 2) &#123; for (var i = 0; i &lt; n-2; i ++) &#123; third = first + secend; first = secend; secend = third; &#125; console.log(third);&#125;else &#123; console.log(1);&#125; 编写程序， 输入一个三位数的正整数， 输出时反向输出。如：456 —&gt; 654 1 输入a, b, c三个数字，打印出最大的 1234567891011121314var n = parseInt(window.prompt('input'));if (a &gt; b) &#123; if (a &gt; c) &#123; console.log(a) &#125;else &#123; console.log(c) &#125;&#125;else &#123; if (b &gt; c) &#123; console.log(b) &#125;else &#123; console.log(c) &#125;&#125; 打印出100以内的质数 123456789101112var count = 0;for (var i = 2; i &lt; 100; i++) &#123; for (var j = 1; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; count ++; &#125; &#125; if (count == 1) &#123; console.log(i + \" \") &#125; count = 0;&#125; switch case， break， continue1234567891011121314var data = window.prompt('input');switch (data) &#123; case \"monday\": case \"wednesday\": case \"thursday\": case \"friday\": console.log('wroking'); break; case \"saturday\": case \"sunday\": console.log('relaxing'); break;&#125; break ———— 终止循环（只要是循环就可以用，而且要写在循环里面） continue —— 终止本次循环，继续下次循环 typeof 类型转换 数组12var arr = [1, 2, 3, 4, undefined, [], &#123;&#125;];// 里面可以放很多东西 对象12var obj = &#123;lastname: \"huang\", male: \"male\", number: 123&#125;// 里面可以放很多东西 编程形式的区别 面向过程（分步骤，能不能做） 面向对象（谁来做） typeoftypeof可以给我们返回6个值 *Number String boolean object undefined function * 两种写法 123typeof('123');typeof '123'typeof(null); // object—— 历史遗留问题 类型转换显式类型转换1234567891011121314151617181920212223242526Number(undefined); // NaNNumber('a'); // NaN/*那些看起来不是数字的，就转不了*/parseInt() // 函数可解析一个字符串，并返回一个整数。相当于Number的小弟/*parseInt(’10‘, 16) ——&gt; 16 16为基底，转化为10进制的数parseInt(string, radix) ---&gt; radio取值范围[2, 32]parseInt(’10abc‘) ————&gt; 返回数值10*/parseFloat(1222.22); // 1222.22 类似parseInt(), 但是只有一个参数，转化为浮点型String(123) // '123' String(mix)转换为字符串类型Boolean(value); /* 转换为布尔类型如果省略 value 参数，或者设置为 0、-0、null、\"\"、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 \"false\"）*/toString()var demo = 123;var num = demo.toString(); // undefined 和 NaN 用不了这个方法/*demo.toString(redix); 把123转换为目标进制的数，跟 parseInt(string, radix) 配合用，可以转来转去*/ 隐式类型转换12345678910111213141516171819202122232425262728293031console.log(isNaN(NaN)); // trueconsole.log(isNaN(\"NaN\")); // trueconsole.log(isNaN(abc)); // 报错console.log(isNaN(123)); // falseconsole.log(isNaN(\"abc\")); // true/*为啥会这样子呢？因为调用 isNaN() 的时候会隐式调用 Number(\"abc\"),然后再跟 NaN 比对isNaN(null) ——&gt; Number(null) -&gt; 0 ——&gt; NaN 所以结果是false*/// ++ 、-- 、+/- 、* 、/ 、% 、|| 、&amp;&amp; 、! 、&gt; 、&lt; 、&gt;= 、&lt;= 、== 、!=undefined == null // trueNaN == NaN // falsetypeof (+'abc') // numbertypeof(a); // undefined 未定义的变量在typeof里面不报错typeof(typeof(a)) // \"undefined\"function myIsNaN(num) &#123; var ret = Number(num); ret += \"\"; if (ret == \"NaN\") &#123; return true; &#125;else &#123; return false; &#125;&#125; 例子： 12345678910111213141516171819202122232425var str = false + 1;console.log(str); // 1 var demo = false == 1;console.log(demo); // falseif (typeof(a) &amp;&amp; -true + (+undefined) + \"\") &#123; console.log(\"基础扎实\"); /* typeof(a) == \"undefined\" -true == -1 +undefined == NaN */&#125;if (11 + \"11\" * 2 == 33) &#123; console.log(\"基础扎实\") /* \"11\" * 2 == 22, \"11\" - 2 == 9, \"10\" / 2 == 5, \"11\" + 2 = \"112\" \"11\" % 2 == 1, +\"11\" + 2 = 13 */&#125;!!\" \" + !!\"\" - !!false || console.log('能打印，猪都能上树');// true + false - false == 1 不发生类型转换的=== 、!==","categories":[{"name":"web前端","slug":"web前端","permalink":"http://www.hsiliver.space/categories/web前端/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.hsiliver.space/tags/javascript/"},{"name":"js简介","slug":"js简介","permalink":"http://www.hsiliver.space/tags/js简介/"},{"name":"变量声明","slug":"变量声明","permalink":"http://www.hsiliver.space/tags/变量声明/"},{"name":"浏览器内核","slug":"浏览器内核","permalink":"http://www.hsiliver.space/tags/浏览器内核/"},{"name":"堆栈数据","slug":"堆栈数据","permalink":"http://www.hsiliver.space/tags/堆栈数据/"},{"name":"if语句","slug":"if语句","permalink":"http://www.hsiliver.space/tags/if语句/"},{"name":"for循环","slug":"for循环","permalink":"http://www.hsiliver.space/tags/for循环/"},{"name":"运算符","slug":"运算符","permalink":"http://www.hsiliver.space/tags/运算符/"},{"name":"类型转换","slug":"类型转换","permalink":"http://www.hsiliver.space/tags/类型转换/"}]}]}
{"meta":{"title":"hsiliver个人博客","subtitle":null,"description":"web前端 js基础 个人博客","author":"hsiliver","url":"https://hsiliver.space/myblog","root":"/myblog/"},"pages":[{"title":"categories","date":"2019-07-08T06:05:17.000Z","updated":"2019-07-08T06:05:52.587Z","comments":false,"path":"categories/index.html","permalink":"https://hsiliver.space/myblog/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-08T06:04:58.000Z","updated":"2019-07-08T06:31:48.344Z","comments":false,"path":"tags/index.html","permalink":"https://hsiliver.space/myblog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"对象包装类","slug":"对象包装类","date":"2019-07-08T13:53:58.000Z","updated":"2019-07-08T14:02:39.185Z","comments":true,"path":"2019/07/08/对象包装类/","link":"","permalink":"https://hsiliver.space/myblog/2019/07/08/对象包装类/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"函数_作用域链","slug":"函数_作用域链","date":"2019-07-08T08:18:49.000Z","updated":"2019-07-08T14:10:29.448Z","comments":true,"path":"2019/07/08/函数_作用域链/","link":"","permalink":"https://hsiliver.space/myblog/2019/07/08/函数_作用域链/","excerpt":"","text":"函数作用域链 函数函数声明高内聚， 低耦合 命名规范：小驼峰式命名 123451. 命名函数表达式function theFirstFun() &#123; console.log('abc');&#125;theFirstFun.name // theFirstFun ​ 表达式类函数，忽略函数名, 此时 abc 被忽略 1234562. 匿名函数表达式 ———— 后来叫做函数表达式var test = function abc() &#123; console.log('abc')&#125;test();test.name // abc 函数传参 12345678910111213141516171819202122232425262728293031323334// 形参 ———— delete 删除不了function sum(a, b) &#123; console.log(sum.length) // 2 形参长度 console.log(arguments.length) // 3 实参长度 // 等同于在函数内部声明了 a, b var c = a + b; coonsole.log(c) // 每个函数在出生的时候系统就会隐式地创建一个arguments（类数组）来装实参——实参列表&#125;// 实参sum(1, 2, 3)function sum1(a, b, c) &#123; // 现在的情况是 // var a = 1; // var b = 2; // var c; // arguments =&gt; [1, 2] 实参只有 2 位 // 然后我们改变规则 a = 10; console.log(arguments[0]); // 10 // 我们再改变一次 arguments[0] = 20; console.log(a); // 20 // 我们会发现这中间存在映射规则 实参的每一位对应形参的每一位 c = 30; console.log(arguments[2]); // undifined; // 所以得出 实参出生的时候有几个 就是几个&#125;sum1(1, 2); 函数的 return 值函数的结束条件 + 返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function sum(a) &#123; console.log(a); return '123'; // 有中断 并且 返回值 结束的功能, 不会打印下面的20 console.log(20); // 2 &#125;sum(2);// 123 倒叙且变中文function reverse() &#123; var num = window.prompt('input'); var str = \"\"; for (var i = num.length - 1; i &gt;= 0; i --) &#123; // 倒着加 2 =》 1 =》 0 str += transfer(num[i]); &#125; console.log(str);&#125;function transfer(target) &#123; switch (target) &#123; case \"1\": return \"壹\"； case \"2\": return \"俩\" case \"3\": return \"仨\" &#125;&#125;// 阶乘// 递归 —— 唯一好处，简洁代码function jc(n) &#123; if (n == 1 || n == 0) &#123; return 1; // 出口， 不然就在无穷死循环 &#125; return n * jc(n-1)&#125;// 1. 找规律// 2. 找出口// 斐波那契数列 fn(n) == fb(n - 1) + fb(n -2)function fb(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125; 作用域初探JS运行分三步：语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。 全局变量：在函数外声明的变量 局部变量：在一个区域内声明的变量预编译 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量归全局所有。 a = 123; 一切声明的全局变量，全是window的属性。window就是全局的域 1234var a = 123;console.log(window.a); // 123// 等同于：window &#123;a : 123&#125; 函数预编译四部曲 123456789101112131415fn(1);function fn() &#123;console.log(a); // ƒ a() &#123;&#125; var a = 123; // 提升到第 2 位 覆盖第一个 a console.log(a); // 123 function a() &#123;&#125;; // 提升到第 1 位 console.log(a); // 123 var b = function () &#123;&#125;// 提升到第 2 位 console.log(b); // ƒ () &#123;&#125; function d() &#123;&#125; // 提升到第 1 位&#125; 创建AO对象 (action object 由于这个函数而产生的存储空间库) 1AO &#123;&#125; 找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined 12345678AO &#123; // arguments : [1], // this : window, // 这里还有两步，这里为了方便，先注释，不考虑。 a : undefined, b : undefined,&#125; 将实参值和形参统一 12345AO &#123; a: 1, b: function () &#123;&#125;, // 形参没有对应的实参就不用管&#125; 在函数体里面找函数声明， 值赋予函数体 *（函数表达式提升不了，它是表达式） 123456789101112AO &#123; a: function a() &#123;&#125;,// 覆盖了形参的a b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;=====&gt;AO &#123; a: 123, // 执行完第一个console.log后，a再度覆盖fn b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;// 一句一句执行 例子2： 12345678910111213141516171819202122232425262728293031323334353637383940function test(a, b) &#123; console.log(a); c = 0; var c; a = 3; b = 2; console.log(b); function b() &#123;&#125; function d() &#123;&#125; console.log(b);&#125;test(1);/*1. AO &#123;&#125;2. AO &#123; a: undefined, b: undefined,&#125;3. AO &#123; a: 1, b: undefined,&#125;4. AO &#123; a: 1, b: function b() &#123;&#125;, d: function d() &#123;&#125;&#125;所以第一个console.log(a) =&gt; 1然后继续AO &#123; a: 3, b: 2, c: 0, d: function d() &#123;&#125;&#125;所以后面两个console.log(b) 都是 2*/(window.foo || (window.foo = 'bar'));// bar 全局：global object( GO ) GO === window 作用域，作用域链函数作用域[[scope]] [[scope]] : 每个javascript函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供javascript引擎存取，[[scope]] 就是其中一个。[[scope]] 指的就是函数的作用域，其中存储了执行期上下文的集合。 执行期上下文： 当函数执行前一刻，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。 作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们称这种链式链接为作用域链。查找变量时，要从作用域链的顶部开始查找。Activation Object（AO）到Global Object（GO）。 查找变量： 从作用域链的顶端依次向下查找 1234567891011121314151617181920function a() &#123; function b() &#123; var bb =234; &#125; var aa = 123; b();&#125;var glob = 100;a();// a defined(定义) a.[[scope]] --&gt; 0 : GO// a doing(执行) a.[[scope]] --&gt; 0 : a-AO// 1 : GO// b defined(定义) b.[[scope]] --&gt; 0 : a-AO// 1 : GO// b doing(执行) b.[[scope]] --&gt; 0 : b-AO// 1 : a-AO// 2 : GO 闭包1 当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。 危害：闭包会导致原有作用于连不释放，造成内存泄漏（占的多了，剩的就少了） 闭包问题的解决方法：立即执行函数、let 详细解释： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO），执行期上下文定义了一个函数执行时的环境。 函数还会获得它所在作用域的作用域链，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。 函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。 但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。 1234567891011121314151617function a() &#123; function b() &#123; var bbb = 234; console.log(aaa); &#125; var aaa = 123; return b;&#125;var glob = 100;var demo = a();demo(); // 123/*f b() &#123;&#125; 被保存出来了并且赋给了demo虽然return后 a 的执行期上下文被销毁，但是b函数[[scope]]=&gt; aAO, bAO, GO所以顺着链找就可以找到 ‘var aaa = 123;'*/ 12345678910111213141516// 闭包作用于累加function a() &#123; var num = 100; function b() &#123; num ++; console.log(num); &#125; return b;&#125;var demo = a();demo(); // 101demo(); // 102/*第二个为啥是102 呢？第一次demo执行完了后，a的AO依然被销毁，但是b的[[scope]]里面存的是第一次demo();后的aAO，事实上就是a斩断了aAO的线，想要销毁，但是b的手里撰着aAO，所以第一次执行产生的aAO，GO被永远当成了基础来用了;*/ 1234567891011121314151617// 闭包作用于缓存（储存结构）function test() &#123; var num = 100; function a() &#123; num ++; cosole.log(num); &#125; function b() &#123; num --; console.log(num); &#125; return [a, b];&#125;var myArr = test();myArr[0](); // 101myArr[1](); // 100// 被保存出来的f a() &#123;&#125; 和 f b() &#123;&#125; 共用一个testAO 立即执行函数 函数出生的时候都是等待被执行的，这个过程是很占内存的，尤其是那些只被执行一次就销毁的函数, 所以有了立即执行函数，执行完就被销毁，这是跟普通函数的唯一区别，其他一样，有执行期上下文，可以传参等等 针对初始化功能的函数 1234567891011121314(function () &#123;&#125;()); // W3C 建议第一种(function () &#123;&#125;)();var test = function () &#123; console.log(123);&#125;();+ function test() &#123;&#125;();- function test() &#123;&#125;();! function test() &#123;&#125;();// 陷阱function test(a, b, c, d) &#123; console.log(a, b, c, d)&#125;(1, 2, 3, 4);// 比报错也不执行 闭包2 针对for循环 123456789101112131415161718function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + \" \"); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;// 10个10/*我们只看第一个for循环， 因为第二个只是为了执行在for循环中 i 是不停在变的，我们要知道，函数只有在执行的时候才会被读取语句，当return完的时候，test函数才执行结束，而此时所有return出来的函数用的都是 test的AO，并且这个testAO里面for循环出来的i已经变成 10 了，当我们执行 myArr 的时候，用的就是 i = 10*/ 解决办法 1234567891011121314// (es6) letfunction test() &#123; var arr = []; for (let i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + \" \"); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125; 1234567891011121314151617181920212223242526272829303132333435function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; (function (j) &#123; arr[j] = function () &#123; document.write(j + \" \"); &#125; &#125;(i)) &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;/*在for循环中：(function (0) &#123; // j = 0 arr[0] = function () &#123; document.write(j + \" \"); &#125;&#125;(0)) // ———— 马上执行，然后将arr[0]丢到test的arr里面，等待被return出去,// 此时立即执行函数的AO依然被arr[0]这个函数保存在arr[0]的[[scope]]里 (function (1) &#123; // j = 1 arr[1] = function () &#123; document.write(j + \" \"); &#125;&#125;(1)) // ———— 马上执行，然后将arr[1]丢到test的arr里面，等待被return出去................*/ 1234567891011121314151617181920212223function test () &#123; var food = \"apple\"; var obj = &#123; eatFood : function () &#123; if (food != \"\") &#123; console.log(\"I am eating \" + food); food = \"\"; &#125;else &#123; console.log(\"There is nothing!\"); &#125; &#125;, pushFood: function (myFood) &#123; food = myFood &#125; &#125; return obj;&#125;var person = test();person.eatFood(); // I am eating appleperson.eatFood(); // There is nothing!person.pushFood('banana'); person.eatFood(); // I am eating banana// 大家保存的都是同一个域，所以公用food这个变量（缓存） 12345678910111213141516171819202122&lt;!-- 阿里巴巴uc事业社招笔试题 --&gt;&lt;!--使用原生js，addEventListener，给每个li元素绑定一个click事件，输出他们的顺序--&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function () &#123; var ulList = document.getElementsByTagName('ul')[0]; var liList = ulList.getElementsByTagName('li'); for (var i = 0; i &lt; liList.length; i++) &#123; (function (j) &#123; liList[j].addEventListener('click', function (j) &#123; console.log(j) &#125;) &#125;(i)) &#125; &#125; // 同样可以用let解决&lt;/script&gt; 1234567891011121314151617/* 腾讯微店写一个方法，求一个字符串的字节长度提示： charCodeAt(); 一个中文占两个字节, 一个英文占两个字节, charCodeAt()方法可返回置顶位置的字符得到Unicode编码，这个返回值是0-65535之间的整数当返回值是 &lt;= 255时为英文（占1个字节）, 当返回值 &gt; 255 时为中文（占2个字节）*/ function retByteslen(target) &#123; var count, len; count = len = target.length; for (var i = 0; i &lt; len; i++) &#123; if (target.charCodeAt(i) &gt; 255) &#123; count ++; &#125; &#125; console.log(count);&#125; 逗号表达式 12345678910111213141516171819202122232425var a = (1 - 1, 1 + 1, 2 + 5);console.log(a); // 7// 一定要用括号括起来， 括号里面需要计算的先计算，，最后返回最后一个的计算结果var f = (function f() &#123; return \"1\"; &#125;,function g() &#123; return 2 &#125;)();console.log(typeof(f)) // numbervar x = 1;if (function f() &#123;&#125;) &#123; // (function f() &#123;&#125;) ==&gt; 被括号变成了表达式，函数名被忽略了 x += typeof f;&#125;console.log(x); // \"1undefined\"// 阿里巴巴UC社招笔试题： body 插入 一个div（原生js）var oDiv = document.createElement('div');var body = document.getElementsByTagName('body')[0];body.appendChild(oDiv);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hsiliver.space/myblog/tags/javascript/"}]},{"title":"js简介","slug":"js简介","date":"2019-07-08T06:45:09.000Z","updated":"2019-07-08T14:02:17.147Z","comments":true,"path":"2019/07/08/js简介/","link":"","permalink":"https://hsiliver.space/myblog/2019/07/08/js简介/","excerpt":"","text":"js —— Javascript：解释性语言 js ——JavaScript：解释性语言同时也叫 ECMAScript 编译 C，C++等 ​ 优点：快 ​ 不足：移植性不好，(不跨平台) 解释 javascrip， php等 ​ 优点：跨平台（不需要编译成文件） ​ 不足：稍慢 混合型 Java ​ .java –&gt;javac –&gt; 编译 –&gt; .class —-&gt; jvm —-&gt; 解释执行（两个都不是） 生活中的异步就是js的同步 单线程，同一时间处理一件事 那是怎么模拟成多线程呢？处理事件足够快的情况下，就可以做到看起来同时在做同一时间在做多件事 专业术语： 轮转时间片（争抢时间） 主流浏览器： ​ IE —————— trident ​ Chrom ———— webkit / blink ​ Firefox ———— Gecko ​ Opera ———— presto ​ Safari ———— webkit 引入js ​ 页面嵌入&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; ​ 外部js文件&lt;script type=&quot;text/javascript&quot; src=&quot;./***.js&quot;&gt;&lt;/script&gt; ​ 为符合W3C标准 结构(html) 行为(js) 样式(css) 相分离 ​ 编程语言特点： 有变量( variable ) ​ html，css属于脚本语言，计算机语言( 依然不影响它们的强大 ) 变量声明 ​ var a;—— 向window申请一个地方叫a ​ 多个变量时尽量单一 var 123var a, b, c; 变量赋值 ​ a = 100;—— 把100给a ​ 再次赋值111给 a ，则原来100会被替换 变量命名规则 变量名必须以包括 英文字母，_ , $ 开头 变量名可以包括 英文字母， _ , $ 数字 不可以用系统关键字(var new break else等)， 保留字作为变量名 (float int long class等) 运算优先级 &gt; 赋值 值的类型 原始值 （stack）栈内存 first in, last out （不可改变性） ​ Number ———— 数字（1, 2, 3, 4） ​ Boolean ———— 布尔（true / false） ​ String ————— 字符串（’ 123 ‘， “ 123 “） ​ undefined ——— 没有定义的（undefined） ​ null —————— 空—–占位（null） 引用值（heap）堆内存 ​ Array ————— 数组（[1, 2, 3, 4]） ​ Object ———— 对象（{a: 1, b: 2}） ​ function ——— 函数（function () {}） ​ Data ————— Data（） ​ RegExp ———— 正则（//） Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中; 栈内存与栈内存之间是复制的关系var b = a; 12345678var num = 100;var num1 = num;num = 200；事实上 —— 100 依然存在，只是剪断了 num 与 100 的关系然后重新在 window 弄了个 num1 再然后将原来的 num值（100）赋给 num1，最后又重新找window要了个地方叫num，将原来的num地方抹去变量名，再把200赋值给num Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量（地址）储存在栈中，通过指针（这个地址）指向储存在堆中的实际对象 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。 Boolean 如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。 Date 返回日期的文字表示法。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] } Number 返回数字的文字表示。 String 返回 String 对象的值。 默认 返回 “[object objectname]”，其中 objectname 是对象类型的名称。 123var arr = [1, 2];var arr1 = arr;arr.push(3); 123var arr = [1, 2];var arr1 = arr;arr = [1, 3]; js语句基本规则 语句后面加分号结束 “ ; “ js语法错误会引发后续代码终止，但不会影响其他js代码块 低级错误：（语法解析错误）出现中文符号等 逻辑错误：（标准错误， 情有可原）没有定义变量等 一个&lt;script type=&quot;text/javascript&quot;&gt;&lt;script/&gt;就是一个js代码块 书写格式要规范， “ = + / - “ 两遍呢都应该有空格 运算操作符 数学运算，字符串连接 任何数据类型加字符串都等于字符串 “ + “ , “ - “ , “ * “, “ / “ , “ % “ , “ () “ 优先级 “ = “ 最弱， “ () “ 最强 “ ++ “ , “ – “ , “ += “ , “-=” , “ /=” , “ *= “, “ %= “ 1234567891011121314151617181920212223242526272829303132// a++ ——&gt; a = a + 1var a = 10;console.log( a++ ); // 先打印a，再 ++ 10var b = 20;console.log( ++b ); // 先 ++ ，再打印a 21var num1 = 10;var num2 = ++num1 - 1 + num1++; // 但是工作这样写是不行的，要新人都可以看懂才好console.log(num2 + ' ' + num1); // 21 12 // num += 10; ——&gt; num = num + 10// 交换 n 和 m 的值var n = 123;var m = 234;1. var c = n; n = m; m = c;2. a = a + b; b = a - b; a = a - b;3. var a = 1 + 'a'; // 1a var b = 0 / 0; // NaN var c = 1 / 0; // infinity4. var a = 1; var b = ++a + 1; // 3 '++'第一运算 var c = a++ + 1; // 2 '++'最后才运算 比较运算符 “ &lt; “ , “ &gt; “ , “ = “ , “ &gt;= “ , “ &lt;= “ , “==” , “ != “ , “ === “ 字符串比较的是 ASCLL 码 123456var a = '10' &gt; '8'; // false&#123;&#125; == &#123;&#125;; // false[] == []; // falsenull == undefined; // true 逻辑运算符 “ &amp;&amp; “ , “ || “ , “ !“ —— 运算的结果为真实值 “ &amp;&amp; “ —— 表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就返回表达式的值了，简单来说：遇到为false的值返回 这个值，遇到全为true的值就返回 最后一个值, 有中断的作用，所以可以作为”如果，那么”: 12 &gt; 1 &amp;&amp; document.write('aaa') “ || “ —— 遇到为true的值返回 这个值，遇到全为false的值就返回 最后一个值 “! “ —— 转换为布尔值再取反， !!NaN转换为布尔值, 调用Boolean() undefined, null, NaN, “”, 0 —— 这五个值返回的布尔值都是FALSE 条件语句循环语句 if语句 —— 括号里的条件为true就运行 “{}” 里面的 1234567891011if (1 &gt; 0 &amp;&amp; 2 &gt; 0) &#123; console.log('a');&#125;if () &#123; &#125;else if () &#123; // 类似排除法 &#125;else &#123; &#125; for循环 12345678910111213141516171819202122232425262728for ( var i = 0; i &lt; 10; i++ ) &#123; // (1) —————（2）—————（3） // 减少我们的重复 console.log('a') // 打印10个a&#125;/* for 循环执行顺序： 先执行一遍（1） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 直到（2）有一次条件不成立，立马停止1. var i = 0;2. if (i &lt; 10) &#123; console.log('a')&#125;3. i++; ---&gt; i = 1;4. if (i &lt; 10) &#123; console.log('a')&#125;5. …………*/ while循环（简化版的for循环） 123456789101112var i = 0;/*for (;i &lt; 10;) &#123; console.log(i); i++;&#125;*/while (i &lt; 10) &#123; console.log(i); i++;&#125;// 两个一样的效果 练习： 计算2的n次幂，n可输入，n为自然数 1234567var n = parseInt(window.prompt('input'));var mul = 1;for (var i = 0; i &lt; n; i ++) &#123; mul *= 2;&#125;console.log(mul)// 先找规律，在写 计算n的阶乘，n可输入 1234567var n = parseInt(window.prompt('input'));// parseInt() 函数可解析一个字符串，并返回一个整数。var mul = 1;for (var i = 1; i &lt;= n; i ++) &#123; mul *= i;&#125;console.log(mul); 著名的斐波那契数列， 输出第n项 1234567891011121314var n = parseInt(window.prompt('input'));var first = 1, secend = 2, third;if (n &gt; 2) &#123; for (var i = 0; i &lt; n-2; i ++) &#123; third = first + secend; first = secend; secend = third; &#125; console.log(third);&#125;else &#123; console.log(1);&#125; 编写程序， 输入一个三位数的正整数， 输出时反向输出。如：456 —&gt; 654 1 输入a, b, c三个数字，打印出最大的 1234567891011121314var n = parseInt(window.prompt('input'));if (a &gt; b) &#123; if (a &gt; c) &#123; console.log(a) &#125;else &#123; console.log(c) &#125;&#125;else &#123; if (b &gt; c) &#123; console.log(b) &#125;else &#123; console.log(c) &#125;&#125; 打印出100以内的质数 123456789101112var count = 0;for (var i = 2; i &lt; 100; i++) &#123; for (var j = 1; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; count ++; &#125; &#125; if (count == 1) &#123; console.log(i + \" \") &#125; count = 0;&#125; switch case， break， continue1234567891011121314var data = window.prompt('input');switch (data) &#123; case \"monday\": case \"wednesday\": case \"thursday\": case \"friday\": console.log('wroking'); break; case \"saturday\": case \"sunday\": console.log('relaxing'); break;&#125; break ———— 终止循环（只要是循环就可以用，而且要写在循环里面） continue —— 终止本次循环，继续下次循环 typeof 类型转换 数组12var arr = [1, 2, 3, 4, undefined, [], &#123;&#125;];// 里面可以放很多东西 对象12var obj = &#123;lastname: \"huang\", male: \"male\", number: 123&#125;// 里面可以放很多东西 编程形式的区别 面向过程（分步骤，能不能做） 面向对象（谁来做） typeoftypeof可以给我们返回6个值 *Number String boolean object undefined function * 两种写法 123typeof('123');typeof '123'typeof(null); // object—— 历史遗留问题 类型转换显式类型转换1234567891011121314151617181920212223242526Number(undefined); // NaNNumber('a'); // NaN/*那些看起来不是数字的，就转不了*/parseInt() // 函数可解析一个字符串，并返回一个整数。相当于Number的小弟/*parseInt(’10‘, 16) ——&gt; 16 16为基底，转化为10进制的数parseInt(string, radix) ---&gt; radio取值范围[2, 32]parseInt(’10abc‘) ————&gt; 返回数值10*/parseFloat(1222.22); // 1222.22 类似parseInt(), 但是只有一个参数，转化为浮点型String(123) // '123' String(mix)转换为字符串类型Boolean(value); /* 转换为布尔类型如果省略 value 参数，或者设置为 0、-0、null、\"\"、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 \"false\"）*/toString()var demo = 123;var num = demo.toString(); // undefined 和 NaN 用不了这个方法/*demo.toString(redix); 把123转换为目标进制的数，跟 parseInt(string, radix) 配合用，可以转来转去*/ 隐式类型转换12345678910111213141516171819202122232425262728293031console.log(isNaN(NaN)); // trueconsole.log(isNaN(\"NaN\")); // trueconsole.log(isNaN(abc)); // 报错console.log(isNaN(123)); // falseconsole.log(isNaN(\"abc\")); // true/*为啥会这样子呢？因为调用 isNaN() 的时候会隐式调用 Number(\"abc\"),然后再跟 NaN 比对isNaN(null) ——&gt; Number(null) -&gt; 0 ——&gt; NaN 所以结果是false*/// ++ 、-- 、+/- 、* 、/ 、% 、|| 、&amp;&amp; 、! 、&gt; 、&lt; 、&gt;= 、&lt;= 、== 、!=undefined == null // trueNaN == NaN // falsetypeof (+'abc') // numbertypeof(a); // undefined 未定义的变量在typeof里面不报错typeof(typeof(a)) // \"undefined\"function myIsNaN(num) &#123; var ret = Number(num); ret += \"\"; if (ret == \"NaN\") &#123; return true; &#125;else &#123; return false; &#125;&#125; 例子： 12345678910111213141516171819202122232425var str = false + 1;console.log(str); // 1 var demo = false == 1;console.log(demo); // falseif (typeof(a) &amp;&amp; -true + (+undefined) + \"\") &#123; console.log(\"基础扎实\"); /* typeof(a) == \"undefined\" -true == -1 +undefined == NaN */&#125;if (11 + \"11\" * 2 == 33) &#123; console.log(\"基础扎实\") /* \"11\" * 2 == 22, \"11\" - 2 == 9, \"10\" / 2 == 5, \"11\" + 2 = \"112\" \"11\" % 2 == 1, +\"11\" + 2 = 13 */&#125;!!\" \" + !!\"\" - !!false || console.log('能打印，猪都能上树');// true + false - false == 1 不发生类型转换的=== 、!==","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://hsiliver.space/myblog/tags/javascript/"}]}]}
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F07%2F09%2FREADME%2F</url>
    <content type="text"><![CDATA[js简介函数_作用域链对象_包装类原型，原型链让call-apply原形毕露继承模式，命名空间this小知识数组try…catch,es5严格模式DOM 知识点date对象、定时器获取视口属性，脚本化事件JSON正则表达式]]></content>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式作用：匹配特殊字符或有特殊搭配原则的字符的最佳选择 最基本用法： 转移字符 “ \ “ : 会把 \ 后面的字符转为文本 “ \n “ : 回车键 “ \r “ : 该文本行结束 “ \t “ : 一个tab（制表符缩进） 两种创建方式 直接量(常用) 12345var reg = /abc/; // 定义一个匹配abc的规则var str = 'abcd';reg.test(str); // 测试方法：是否符合上面的reg规则var reg = /abc/i; // 忽视大小写（ignoreCase） new RegExp(); 12345678910var reg = new RegExp("abc", 'i');第二个值填匹配规则var str = 'ABCD';reg.test(str);// 效果同上var reg1 = new RegExp(reg)// reg1跟reg内容相同，但本质上不是同一个var reg2 = RegExp(reg);// reg跟reg2内容相同， 并且本质上是同一个人（当然也没什么人这么用） 1234567var reg = /ab/;var str = "abbababab";str.match(reg); // 返回["ab"]// 如果全局匹配var reg = /ab/g;// 返回的就是所有的匹配正确的 ["ab", "ab", "ab", "ab"] 123var reg = /^a/g; // 匹配全局 以a开头 的所有符合要求的 ["a"]var str = "abcde\na";var reg = /^a/gm; // m具有匹配多行的功能，["a", "a"] 两种常用的方法 reg.test()：返回值只有true、false str.match() ： 返回具体匹配的项 123456// 当我们需要匹配多位的时候，就可以使用表达式“[]”了,里面填可以取到的范围var reg = /[1234567890][1234567890][1234567890]/g;// 还可以偷懒写 [0-9A-z], 正则也是符合ASCLL码匹配的// 全局匹配连着3位是数字0-9的符合要求的var str = "123adsdaf45730258afdgw";// ["123", "457", "302"] 1var reg = /(abc|bcd)/g; // 全局匹配abc或bcd，正则里的 “|” 代表或 元字符 1234567891011var reg = /\w/g;/*/\w === [0-9A-z_];\W === [^\w]; ==&gt;[非\w]\d === [0-9];\D === [^\d];同时表达式里面也是可以写元字符的 var reg = /[\w]/g\s === [空白字符] ==&gt; 空格( )，回车(\r)， 制表(\t)，换行(\n)，垂直换行(\v)，换页(\f)\S === [^\s];/* 12345678910var reg = /\bcde\b/g;var str = "abc cde fgh";// ["cde"]// \b === 单词边界// \B === 非单词边界var reg = /[\u0000-\uffff]/g; // 匹配所有// . === [^\r\n]; 123456789var reg = /\w+/g;// 全局匹配 \w "可以" 出现无数次// n+ ==&gt; &#123;1, infinity&#125;// n* ==&gt; &#123;0, infinity&#125;// 贪婪匹配原则var reg = /\w*/g;var str = "abc"; // ["abc", ""] 123var reg = /\d*/g;var str = "abc"; // ["", "", "", ""]// 不能识别的就用会空代表 12345678var reg = /\w?/g;var str = "aaa";// ["a", "a", "a", ""]// n? ==&gt; &#123;0, 1&#125;// n&#123;x, &#125; ==&gt; &#123;x, infinity&#125;// 贪婪匹配原则var reg = /\w&#123;1, 3&#125;/g; // 全局匹配1-3个var str = "aaaa"; // ["aaa", "a"]; 1234var reg = /^sd$/g; // 以sd开头，以sd结尾var str = "sd"; // ["sd"]// n$ ==&gt; 以什么结尾// ^n ==&gt; 以什么开头 检验一个字符串，首尾是否含有数字的 正则表达式 12var reg = /^\d|\d$/;// 首尾都有数字 var reg = /^\d[\s\S]*\d$/ reg.exec()和reg.lastIndex(鼠标游标位置)，两者是相互配合使用的 如果不加 g 的话，lastIndex不会变，不动 123456789101112131415161718192021222324252627var reg = /ab/g;var str = "abababab";console.log(reg.exec(str));console.log(reg.lastIndex);// 2 ["ab", index: 0, input: "abababab", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 4 ["ab", index: 2, input: "abababab", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 6 ["ab", index: 4, input: "abababab", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 8 ["ab", index: 6, input: "abababab", groups: undefined]console.log(reg.exec(str));console.log(reg.lastIndex);// 0 nullconsole.log(reg.exec(str));console.log(reg.lastIndex);// 2 ["ab", index: 0, input: "abababab", groups: undefined] ()的记录功能 加上括号后括号就会记录里面的内容 123 var str = 'aaaa';var reg = /(\w)\1/g; // 全局匹配 \w\w , \1（反向引用）类似复制一个与第一个子表达式一样的匹配表达式 12345var str = "aabb";var reg = /(\w)\1(\w)\2/g;console.log(reg.exec(str));// ["aabb", "a", "b", index: 0, input: "aaaa", groups: undefined]// 多出来的两位就是 第一个子表达式和第二个子表达式匹配的内容，而且这两位是正式的数据位 str.match() 123456var str = "aabb";var reg = /(\w)\1(\w)\2/;console.log(str.match(reg));// ["aabb", "a", "b", index: 0, input: "aaaa", groups: undefined]// 不加 全局g 的情况下， 返回的结果跟reg的exec方法类似// 一旦加了g 返回 ["aabb"]; str.search()返回匹配到的位置 123456var str = "aabb";var reg = /^bcd$/g;console.log(str.search(reg)); // 一旦匹配不到就返回 -1；var reg1 = /bb$/g;console.log(str.search(reg1)); // 2 "0 a 1 a 2 b 3 b 4",第二位匹配到 str.split()拆开，这个我们很熟悉，不过多解释 str.replace() 替换 12345678// 正常的replace:var str = "aa";console.log(str.replace("a", "b")); // ba, 这就是非正则的缺陷，只能匹配1个// 再来换成正则表达式var reg = /a/;console.log(str.replace(reg)); // ba ，因为没有写 g（全局）var reg1 = /a/g;console.log(str.replace(reg1)); // bb eg : 形如 aabb 的都倒过来 1234567891011var reg = /(\w)\1(\w)\2/;var str = "aabb";console.log(str.replace(reg, "$2$2$1$1")); // 方法1console.log(str.replace(reg, function ($, $1, $2) &#123; // 第一个参数是正则表达式匹配的结果, // 第二个参数是第一个子表达式匹配的内容， // 第三个参数是第二个子表达式匹配的内容， return $2 + $2 + $1 + $1;&#125;))// str.toUpperCase(),变大写// str.toLowerCase(),变小写 eg : the-first-name ===&gt; theFirstName 1234567var reg = /-(\w)/g;var str = "the-first-name";console.log(str.replace(reg, function ($, $1) &#123; return $1.toUpperCase(); // 里面的function是多次执行的&#125;))// 可以制作在线翻译功能 正向预查， 正向断言 1234567var str = "abaaaaa";var reg = /a(?=b)/g; // 全局匹配后面有 b 的 aconsole.log(str.match(reg)); // a// 意思是这个b参与匹配限定，但是不参与返回结果var reg = /a(?!b)/g; // 全局匹配后面没有 b 的 a ==&gt; 非正向预查console.log(str.match(reg));// ["a", "a", "a", "a", "a"]; 非贪婪匹配 12345var str = "aaaa";var reg = /a+/g; // 贪婪var reg1 = /a+?/g // 非贪婪var reg2 = /a&#123;1, 3&#125;?/g; // 有1绝对不取3，？可以打破任何规则var reg3 = /a??/g; // 能取0就不会取1， a? 匹配 0 ~ 1 位a 百度2014最后一道 123456789101112var str = "10000000000"; // 转换为形如 1,000,000,000var reg = /(?=(\B)(\d&#123;3&#125;)+$)/g; /*$ ==&gt; 从后往前查n+ ==&gt; &#123;1, infinity&#125;\d ==&gt; &#123;0-9&#125;\B ==&gt; 非单词边界？= ==&gt; 参与匹配限定，但是不参与返回结果()前面什么也不填 ==&gt; 匹配空*/ str.replace(reg, ".");// 空替换为 "." 去重 123456var str = "aaaaabbbbbccccc";var reg = /(\w)\1*/g;// n* ==&gt; &#123;0~infinity&#125;;// 匹配所有 0到多个 ： ["aaaaa", "bbbbb", "ccccc"]str.replace(reg, "$1");// 将匹配到的替换成第一个子表达式]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON]]></title>
    <url>%2F2019%2F07%2F08%2FJSON%2F</url>
    <content type="text"><![CDATA[JSON JSON是一种数据传输的格式（以对象喂养版，本质上就是对象，但用途有区别，对象就是本地用的，JSON是用来传输的） 格式 属性名必须加双引号，属性值最好加 1234&#123; "name" : "hsz", "age" : 123&#125; 我们传输给后台的是字符串，后台传输给咱们的也是字符串，只不过是JSON格式的字符串&#39;{&quot;name&quot; : &quot;hsz&quot;, &quot;age&quot; : 123}&#39;, 下面这两种方法就是用来转化的 JSON.parse(); string ——&gt; json JSON.stringify(); json ——&gt; string renderTree一. DOM树的完成（2步）1 dom树的解析完成， 2 dom树的加载完成 dom树的解析 1 ） html解析原则：深度优先原则，一条道走到底 2 ） 识别到了就丢到dom树上去, 比如&lt;img src=&quot;&quot;&gt;, dom树不会去管src的内容，认识&lt;img&gt;就完事了 二. CSS树（跟DOM树类似）renderTree = DOMTree + CSSTree当renderTree形成完成后，JavaScript引擎才会开始真正开始绘制页面，按照renderTree里面的每一条规则去绘制页面 三 .renderTree的重排（reflow）和重绘（repaint）renderTree的重排会降低代码运行的效率 1）dom节点的删除，增加 2） dom节点的宽高变化，位置变化 3） offsetLeft offsetWidth（因为要求实时获取，所以要不断重排） renderTree重绘会极少的降低效率（可以接受） dom节点的颜色改变 异步加载为什么js的加载过程和运行过程不能和html、css并行去做呢？ 因为js会修改html和css，要么绘制完了运行，要么运行完了继续绘制 为什么&lt;script&gt;&lt;/script&gt; 要放在最后呢？ 因为如果放在head里面，但凡js里面有一个字节没加载过来，整个页面就废掉了 异步加载三个方案1）defer 异步加载，但要等到dom文档全部解析完才会被执行。可以加载内部脚本 123&lt;script type="text/javascript" src="" defer="defer"&gt; // 但是很遗憾，只有IE9以下可以用&lt;/script&gt; 加上defer后就可以和html，css同时加载了 2） async 异步加载，加载完就执行，async只能加载外部脚本，不可以加载&lt;script&gt;的内部脚本 123&lt;script type="text/javascript" src="" async="async"&gt; // W3C标准方法，只能加载外部脚本&lt;/script&gt; 上面俩，执行时也不会阻塞页面 3）动态创建script，插入到dom中，加载完毕后callback（最常用），还可以按需加载 1234var script = document.createElement('script');script.type = "text/javascript";script.src = "./xxx.js"; // 开始下载"xxx.js"document.head.appendChild(script); // 开始执行"xxx.js" 如果我们想要执行xxx.js里面的方法的话，就需要等到xxx.js下载完成才可能执行 当然我们也有这样的方法 1234567script.onload = function () &#123;&#125; // 就IE不好使script.onreadystatechange = function () &#123; if(script.readState == "complete" || script.readyState == "loaded")&#123; // ie独有 &#125;&#125; 我们可以封装到一起 1234567891011121314151617181920212223242526272829function loadScrpit(url, callback) &#123; var script = document.createElement('script'); script.type = "text/javascript"; if (script.readyState) &#123; script.onreadystatechange = function () &#123; if(script.readState == "complete" || script.readyState == "loaded")&#123; // 1 callback();// ie独有 // 2 eval(callback); tools[callback](); &#125; &#125; &#125;else &#123; script.onload = function () &#123; // 1 callback(); tools[callback](); &#125; &#125; script.src = url;// 开始下载"xxx.js" document.head.appendChild(script); // 开始执行"xxx.js"&#125;// 1 loadScrpit('tools.js', function () &#123;test()&#125;)// 2 loadScrpit('tools.js', "test()");loadScrpit('tools.js', "test");// 但是第三种要求这样写函数体var tools = &#123; test : function () &#123;console.log('a');&#125;, demo : function () &#123;&#125;;&#125; js 加载时间线 1 创建Document对象，开始解析对象，开始解析web页面。解析HTML元素和他们的文本内容后，添加Element对象和Text节点到文档中，这个阶段document.readyState = &#39;loading&#39;. 2 遇到link外部css，创建线程加载，并继续解析文档。 3 遇到script外部js，并且没有设置async、defer。浏览器加载并阻塞，等待加载完成并执行该脚本，然后继续解析文档。 4 遇到script外部js，并且设置有async、defer。浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后执行。（异步禁止使用document.write()） 5 遇到img等，先正常解析dom结构，然后浏览器异步加载src，并继续解析文档。 6 当文档解析完成，document.readyState = &#39;interactive&#39;。 7 文档解析完成后，所有设置有defer的脚本会按照顺序执行。（注意与async不同，但同样禁止document.write()）。 8 document对象触发DOMContentLoaded事件，这也标志着程序执行从 同步脚本执行阶段 转化为事件驱动阶段。(只在addEventListener()好用) 9 当所有async的脚本加载完成并执行后、img的加载完成后，document.readyState = &#39;complete&#39;，window对象触发load事件。 10 从此，以异步响应方式处理用户输入、网络事件等。]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js时间线</tag>
        <tag>异步加载</tag>
        <tag>JSON</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件 —— 交互体验的核心功能]]></title>
    <url>%2F2019%2F07%2F08%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件 —— 交互体验的核心功能 ele.onxxx = function (event) {} 兼容性很好，但是一个元素的同一个事件上只能绑定一个处理程序 基本等同于写在HTML行间上（句柄绑定方式） obj.addEventListener(type, fn, false); IE9 以下不兼容，可以为一个事件绑定多个处理程序（地址不一样的fn） obj.attachEvent(&#39;on&#39;+type, fn); IE 独有，一个事件同样可以绑定多个处理程序 123456789101112131415161718&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; // 点击输出li的序号 window.onload = function () &#123; var oUl = document.getElementsByTagName('ul')[0]; var oLi = document.getElementsByTagName('li'); for (let i = 0; i &lt; oLi.length; i++) &#123; oLi[i].addEventListener('click', function () &#123; console.log(i); &#125;) &#125; &#125;&lt;/script&gt; 封装兼容性事件监听 1234567891011function addEvent(ele, type, handle) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, handle, false); &#125;else if (ele.attachEvent) &#123; ele.attachEvent('on' + type, funciton () &#123; handle.call(ele) &#125;) &#125;else &#123; ele['on' + type] = handle; &#125;&#125; 解除事件 dom.removeEventListener(&#39;click&#39;, fn, false); dom.detachEvent(&#39;on&#39; + type, fn); 事件处理模型——事件冒泡、捕获 事件冒泡： 结构上（非视觉上）嵌套关系的元素， 会存在事件冒泡的功能，即同一时间，自子元素冒泡向父元素（自底向上） 事件捕获： 1 dom.addEventListener()第三个参数为true 2 dom.setCapture(); （仅在IE上好使）捕获页面上所有的事件捕获到自己身上 ​ 对应dom.releaseCapture(); （取消事件捕获） 结构上（非视觉上）嵌套关系的元素， 会存在事件捕获的功能，即同一时间，自父元素捕获至子元素（自顶向下） IE没有捕获事件, 只有谷歌实现了 出发顺序， 先捕获，后冒泡 focus、blur、change、submit、reset、select等事件不冒泡 阻止事件冒泡 123456789101112div.onclick = function (e) &#123; var event = e || window.event;//在IE里(e)不好使 var target = event.target || event.srcElement;//兼容事件源对象 stopBubble(e);&#125;function stopBubble(event) &#123; if(event.stopPropagation)&#123; event.stopPropagation(); &#125;else&#123; event.cancelBubble = true; &#125;&#125; 阻止默认事件 默认事件——表单提交，啊标签跳转，右键菜单等 return false 以对象属性的方式注册的事件才生效（句柄绑定事件生效） event。preventDefault() W3C 标注， IE9以下不兼容 event.returnValue = false 兼容IE 封装阻止默认事件的函数 cancelHandler(event) 1234567891011div.onclick = function (e) &#123; var event = e || window.event; cancelHandler(e);&#125;function cancelHandler(event) &#123; if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; event.returnValue = false; &#125;&#125; 事件对象 谷歌：window.e || e IE：window.event || event 事件源对象 火狐只有event.target IE只有 event.srcElement google :都有 123// 兼容性写法var event = e || window.event;var target = event.target || event.srcElement; 事件委托 优点： 1 性能 ： 不需要循环所有元素一个个绑定 2 灵活 ： 当有新的子元素时不需要重新绑定事件 1234567891011&lt;ul id="ul"&gt; &lt;li&gt;&#123;$1&#125;&lt;/li&gt; * 100&lt;/ul&gt;&lt;script&gt; var oUl = document.getElementsByTagName('ul')[0]; oUl.onclick = funciton (e) &#123; var event = e || window.event; var target = event.target || event.srcElement; console.log(target.innerText); &#125;&lt;/script&gt; 鼠标事件 click、mousedown、mousemove、mouseup、contextmenu、mouseover、mouseout、mouseenter、mouseleave 用button来区分鼠标按键 0 / 1 / 2 W3C标准规定：click事件只能监听左键，，只能通过mousedown和mouseup来判断鼠标键 div拖拽事件 123456789101112131415161718var div = document.getElementsByTagName('div')[0];function drag(dom) &#123; var e = e || window.event; var disX, disY; div.onmousedown = function (e) &#123; disX = e.pageX - parseInt(dom.style.left); disY = e.pageY - parseInt(dom.style.top); document.onmousemove = function (e) &#123; dom.style.left = e.pageX - disX + 'px'; dom.style.top = e.pageY - disY + 'px'; &#125; div.onmouseup = function () &#123; document.onmousemove = null; &#125; &#125;&#125;drag(div) 判断鼠标左右键 1234567document.onmousedown = function (e) &#123; if (e.button == 2) &#123; console.log('右键'); &#125;else &#123; console.log('左键'); &#125;&#125; 如何解决onmousedown和onmouseup与onclick事件冲突 利用用户习惯的事件差设置就可以避免了 123456789101112131415161718var firstTime = 0;var lastTime = 0;var key = true;document.onmousedown = function () &#123; firstTime = new Date().getTime();&#125;document.onmouseup = function () &#123; lastTime = new Date().getTime(); if (lastTime - firstTime &lt; 300) &#123; key = true; &#125;&#125;document.onclick = function () &#123; if (key) &#123; console.log('click'); key = false; &#125;&#125; 移动端：touchstart 、touchmove、touchend 键盘类事件 onkeypress &gt;onkeydown &gt; onkeyup keydown可以相应任意键盘按键，keypress止咳响应字符类键盘按键 keypress返回ASCLL码，可以转换成相应字符 1234document.onkeypress = function (e) &#123; console.log(String.fromCharCode(e.charCode)); // 将ASCLL码转换为键盘上对应的字符&#125; 文本类操作事件 input输入触发、focus聚焦触发、blur失焦触发、change改变内容并且失焦触发 窗体操作类（window上的事件） scroll当滚动轮滚动触发 （懒加载） load （尽量少用）整个页面全部就绪的时候，才执行window.onload,虽然很飘逸，但是效率很低，影响用户体验，但是也有好处：比如广告要等到页面加载完才加上广告。也可以考究需要多久，页面能够正常使用]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>冒泡</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取视口属性，脚本化css]]></title>
    <url>%2F2019%2F07%2F08%2F%E8%8E%B7%E5%8F%96%E8%A7%86%E5%8F%A3%E5%B1%9E%E6%80%A7%EF%BC%8C%E8%84%9A%E6%9C%AC%E5%8C%96css%2F</url>
    <content type="text"><![CDATA[滚动条查看滚动条的滚动距离 window.pageXOffset / pageYOffset IE 8 及 iIE8以下不兼容 document.body / documentElement.scrollLeft / scrollTop 兼容性比较混乱呢，用时取俩值相加，因为不可能存在两个同时有值 封装兼容性方法，求滚动轮滚动距离 getScrollOffset() 12345678910111213function getScrollOffset() &#123; if (window.pageXOffset) &#123; return &#123; x : window.pageXOffset, y : window.pageYOffset &#125; &#125;else &#123; return &#123; x : document.body.scrollLeft + document.documentElement.scrollLeft, y : document.body.scrollTop + document.documentElement.scrollTop, &#125; &#125;&#125; 让滚动条滚动 window上有3个方法 scroll(),scrollTo(),scrollBy() 三个方法功能类似，用法都是x, y 坐标传入。即实现让滚动轮滚动到当前位置。 区别：scrollBy()会在之前的数据基础之上做累加 eg ： 可以利用scrollBy() 快速阅读的功能 视口查看视口尺寸 window.innerWidth/innerHeight IE8及IE8以下不兼容 document.documentElement.clientWidth / clientHeight 标准模式下，任意浏览器都兼容 document.body.clientWidth / clientHeight 适用于怪异模式下的浏览器 封装兼容性方法，返回浏览器视口尺寸getViewportOffset() 1234567891011121314151617181920function getViewportOffset() &#123; if (window.innerWidth) &#123; return &#123; w : window.innerWidth, h : window.innerHeight &#125; &#125;else &#123; if (document.compatMode === "BackCompat") &#123; return &#123; w : document.body.clientWidth, h : document.body.clientHeight &#125; &#125;else &#123; return &#123; w : document.documentElement.clientWidth, h : document.documentElement.clientHeight &#125; &#125; &#125;&#125; 元素尺寸查看元素几何尺寸 domEle.getBoundingClientRect() 兼容性很好 该方法返回一个对象，对象里面有left、top、right、bottom等属性。left和top代表该元素左上角的X坐标和Y坐标，right和bottom代表该元素右下角的X坐标和Y坐标。 height和width属性老IE并未实现 返回的结果并不是实时的 查看元素尺寸 ( 视觉上的尺寸 ) dom.offsetWidth, dom.offsetHeight 查看元素位置 dom.offsetLeft, dom.offsetTop 对于无定位的父级元素，返回相对文档的坐标。对于有定位父级的元素，返回相对于最近的有定位的父级的坐标。无论自身有没有定位，但凡与父级或者文档有距离就返回这个距离 dom.offsetParent 返回最近的由定位的父级，如果没有，返回body，body.offsetParent返回null。 eg : 求元素相对于文档的坐标 getElementPosition 脚本化cssdom.style（获取的是行间样式） 可读可写 注意background-color 等，带 ‘-‘ 号的组合样式, 要小驼峰式命名backgroundColor 碰到float这样的保留字属性，前面加css ——&gt; dom.style.cssFloat = left; 复合属性（一个样式包含多个属性，比如border）尽量拆开写 查询计算样式（已经计算完了，比如 em —&gt; px） window.getComputedStyle(ele, null)[prop]; 这个方法可以获取伪元素的样式 1window.getComputedStyle(div, 'after').width // 这样就可以获取了 计算样式只读（视觉上展示给我们的样式会展示出来，包括默认值） 返回的计算样式的值都是绝对值，没有相对单位 IE8及IE8以下不兼容 IE：dom.currentStyle[prop]但是并非是计算后的属性 12345678// 封装兼容的 查询计算样式function getStyle(elem, prop) &#123; if (window.getComputedStyle) &#123; return window.getComputedStyle(elem, null)[prop]; &#125;else &#123; return elem.currentStyle[prop]; &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>滚动条</tag>
        <tag>视口</tag>
        <tag>脚本化css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日期对象Date()]]></title>
    <url>%2F2019%2F07%2F08%2Fdate%E5%AF%B9%E8%B1%A1%E3%80%81%E5%AE%9A%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[日期对象Date()日期对象：是系统提供好的 注意： 我们new出来的对象是记录的date出生的那一刻，并不是实时地 123456789101112131415161718192021var date = new Date();date.getDate(); // 返回当前这个月的第几天。就是几号（1 ~ 31）date.getDay(); // 返回当前周的第几天（0 ~ 6）date.getMonth(); // 返回当前年的第几个月 （0 ~ 11）date.getFullYear(); // 返回当前年份（四位数）date.getHours(); // 返回当前小时（0 ~ 23）date.getMinutes(); // 返回当前分钟（0 ~ 59）date.getSeconds(); // 返回当前秒钟（0 ~ 59）date.getMilliseconds(); // 返回当前毫秒（0 ~ 999）date.getTime(); // *返回 1970 年 1 月 1 日至今的毫秒数（计算机的纪元时刻，也是最常用的）date.setDate(); // 设置月的第几天。就是几号（1 ~ 31）date.setDay(); // 设置周的第几天（0 ~ 6）date.setMonth(); // 设置年的第几个月 （0 ~ 11）date.setFullYear(); // 设置年份（四位数）date.setHours(); // 设置小时（0 ~ 23）date.setMinutes(); // 设置分钟（0 ~ 59）date.setSeconds(); // 设置秒钟（0 ~ 59）date.setMilliseconds(); // 设置毫秒（0 ~ 999）date.setTime(); // 以毫秒设置date对象 定时循环器setInterval(function () {}, time) 1234var time = 1000;setInterval(function () &#123;&#125;, time);time =2000;// 事实上这个 setInterval 里面的 time 只识别一次，即使在后面再次修改也是不好使的 我们可以来验证定时器到底准不准 123456789var firstTime = new Date().getTime();setInterval(function () &#123; var lastTime = new Date().getTime(); console.log(lastTime - firstTime); firstTime = lastTime;&#125;, 1000)// 结果是很不准的setInterval("console.log('a')", 1000); // 另一种写法每隔1000毫秒运行字符串里面的代码 定时器setTimeout(function () {}, 1000) 只运行一次，运行完成后结束，用法与setInterval相差无几 清除定时、定时循环器clearInterval(); 1234var timer = setInterval(function () &#123;&#125;, 1000);var timer2 = setInterval(function () &#123;&#125;, 2000);console.log(timer, timer2); // 1 2clearInterval(timer); 由于setInterval是window上的一个方法，而每生成一个setInterval，window就会给这个setInterval打上一个唯一标识；我们清除的就是这个标识；]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>Date</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM详解]]></title>
    <url>%2F2019%2F07%2F08%2FDOM%2F</url>
    <content type="text"><![CDATA[DOM什么是DOM？ DOM ——&gt; Document Object Model DOM 定义了表示和修改文档所需的方法，DOM对象即为宿主对象，由浏览器厂商定义，用来操作html和xml功能的一类对象的集合。也有人称DOM是对Html以及xml的标准编程接口。 XML ——&gt; XHTML ——&gt; html, Xml里面的标签可以自定义 操作不了CSS，但是可以通过操作行间样式，间接操作CSS 12345678910111213141516&lt;div&gt;&lt;/div&gt;&lt;script&gt; var div = document.getElementsByTagName('div')[0]; div.style.width = '100px'; div.style.height = '100px'; div.style.backgrounColor = 'orange'; var count = 0; div.onclick = function () &#123; count ++; if (count % 2 == 1) &#123; this.style.backgrounColor = 'yellow'; &#125;else &#123; this.style.backgrounColor = 'orange'; &#125; &#125;&lt;/script&gt; DOM的基本操作1) 对节点的改查 查看元素节点 123456789101112131415161718document // 代表整个文档document.getElementById(); // 元素ID在IE8以下的浏览器，不区分ID大小写，而且也返回匹配name属性的元素&lt;div name="div"&gt;&lt;/div&gt;document.getElementsByTagName(); // 标签名document.getElementsByName(); // 需要注意，只有部分标签name可以生效（表单，表单元素，img，iframe）document.getElementsByClassName(); // 类名，-&gt; IE8和IE8以下的IE版本中没有，可以选中多个classdocument.querySlector() // css选择器，IE7和IE7以下的IE版本中没有,选一个document.querySlector('div &gt; span.demo');// 事实上这两个并不使用，因为是静态的，选中一次后，// 后面再次选中依然以第一次选中的结果为主，是非实时的，镜像的document.querySlectorAll() // css选择器，IE7和IE7以下的IE版本中没有document.querySlector('div &gt; span.demo'); 遍历节点树 1234567891011parentNode -&gt; 父节点（一个元素只有一个父节点）childNodes -&gt; 子节点们firstChild -&gt; 第一个子节点lastChild -&gt; 最后一个子节点nextSibling -&gt; 后一个兄弟节点previousSibling -&gt;前一个兄弟节点 基于元素节点树的遍历 1234567891011parentElement -&gt; 返回当前元素的父元素节点（IE不兼容）children -&gt; 只返回当前元素的子元素节点（兼容性最好，最常用）node.childElementCount === node.children.length -&gt; 当前元素节点的子节点firstElementChild -&gt; 返回的是第一个元素节点（IE不兼容）lastElementChild -&gt; 返回的是最后一个元素节点（IE不兼容）nextElementSibling / previousElementSibling -&gt; 返回后一个/前一个兄弟元素节点 节点的类型 12345678nodeType —&gt; 获取节点的类型， 只读元素节点 ———— 1属性节点 ———— 2文本节点 ———— 3注释节点 ———— 8document —— 9DocumentFragment(文本碎片节点) ———— 11 节点的四个属性 12345678910111213nodeName -&gt; 元素的标签名，大写形式表示 ， 只读nodeValue -&gt; text节点或Comment节点的文本内容 ， 可读可写nodeType —&gt; 该节点的类型， 只读attributes -&gt; Element 节点的属性集合&lt;div id=&quot;demo&quot;&gt;&lt;/div&gt;div.attributes[0].name; // iddiv.attributes.value; // demovalue值可读可写，name值只读节点的一个方法 node.hasChildNodes();返回true/false 1234HTMLDocument.prototype = &#123; __proto__ : Document.prototype&#125;// 所以继承关系是：document --&gt;(继承自) HTMLDocument.prototype --&gt; Document.prototype getElementById方法定义在Document.prototype上，即Element节点上不能使用。 getElementByName方法是在HTMLDocument.prototype上， 即非html中的document不能使用（xml、document、Element） getElementByTagName方法定义在Document.prototype和Element.prototype上 12var div = document.getElemmentsByTagName('div')[0];var span = div.getElementsByTagName('span')[0]; HTMLDocument.prototype定义了一些常用的属性，body，head分别指代HTML文档中的&lt;body&gt;&lt;/body&gt;、&lt;head&gt;&lt;/head&gt;标签 12document.body; //&lt;body&gt;&lt;/body&gt;document.head; //&lt;head&gt;&lt;/head&gt; Document.prototype上定义了document、Element属性，指代文档的根元素，在HTML文档中，它总是指代&lt;html&gt;&lt;/html&gt;元素 1document.documentElement; // &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; getElementsByClassName、querySelector、querySelectorAll在Document.prototype、Element.prototype类中均有定义 练习12345678// 封装函数，返回元素e的第n层祖先元素节点function retParent(elem, n) &#123; while (elem &amp;&amp; n) &#123; elem = ele.parentElement; n --; &#125; return elem;&#125; 1234567891011121314151617181920212223// 封装函数，返回元素e的第n个元素节点，n为正，//返回后面的元素节点，n为负，返回前面的，n为0返回自己function retSibling(e, n) &#123; while (e &amp;&amp; n) &#123; if (n &gt; 0) &#123; if (e.nextElementSibling;) &#123; e = e.nextElementSibling; &#125;else &#123; for (e = e.nextSibling; e &amp;&amp; e.nodeType ! = 1; e = e.nextSibling) // 为了兼容IE9以下 &#125; n --; &#125;else &#123; if (e.previousElementSibling) &#123; e = e.previousElementSibling; &#125;else &#123; for (e = e.previousSibling; e &amp;&amp; e.nodeType != 1; e = e.previousSibling); &#125; n ++; &#125; &#125; return e;&#125; 1234567891011// 编辑函数，封装myChildren功能，解决以前部分浏览器的兼容性问题Element.prototype.myChildren = function () &#123; var child = this.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i ++) &#123; if (chilid[i].nodeType == 1) arr.push(child[i]) &#125; return arr;&#125; 1234567891011// 封装hasChildren()方法，不可用children属性Element.prototype.hasChildren = function () &#123; var child = this.childNodes; var len = child.length; var arr = []; for (var i = 0; i &lt; len; i ++) &#123; if (chilid[i].nodeType == 1) return true; &#125; return false;&#125; 12345678910111213141516// 封装自己的chlidren函数，用nodeTypefunction retElementChild(node) &#123; var temp = &#123; length : 0, push : Array.prototype.push, splice : Array.prototype.splice; &#125;, child = node.childNodes, len = child.length; for (var i = 0; i &lt; len; i ++) &#123; if (child[i].nodeType === 1) &#123; temp.push(child[i]); &#125; &#125; return temp;&#125; 2） 对节点的增、插、删、替换 增 document.createElement() 创建元素节点 document.createTextNode() 创建文本节点 document.createComment() 创建注释节点 document.createDocumentFragment() 创建文档碎片节点 插 ParentNode.appendChild() parentNode 里面 ，列表的最后插入子节点（剪切操作） ParentNode.insertBefore(a, b) parentNode 里面 ，把 a 插入在 b 之前 123456789101112131415// 封装insertAfter函数// &lt;div&gt;// &lt;span&gt;&lt;/span&gt;// &lt;p&gt;&lt;/p&gt;// &lt;div&gt;Element.prototype.insertAfter = function (targetNode, afterNode) &#123; // &lt;i&gt; &lt;p&gt; var beforeNode = afterNode.nextElementSibling; if (beofreNode == null) &#123; this.appendChild(targetNode) &#125;else &#123; this.insertBefore(targetNode,beforeNode); &#125;&#125; 删 parent.removeChild() 删除（剪切出来）自己的子节点（参数可以是某个节点） child.remove() 删除（销毁）自己 替换 parent.replaceChild(new, origin)父级调用，拿新的元素替换老的元素 Element节点上的一些属性 innerHTML —-&gt;读 / 写html结构，覆盖原有所有内容 12div.innerHTML; // 取值操作div.innerHTML = '&lt;p&gt;&lt;/p&gt;'; // 写入操作 innerText(火狐不兼容) / textContent（老版本IE不好使） —&gt; 读 / 写文本内容，覆盖原有所有内容，包括标签结构，所以谨慎使用 Element 节点上的一些方法 ele.setAttribute(); 设置行间属性 1234&lt;div&gt;&lt;/div&gt;div.setsetAttribute(&apos;class&apos;, &apos;demo&apos;);===&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt; ele.getAttribute();获取行间属性，里面填一个参数即可]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM的基本操作</tag>
        <tag>节点树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[try {} catch (e) {}]]></title>
    <url>%2F2019%2F07%2F08%2Ftry...catch%2Ces5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[try {} catch (e) {} 防止部分的代码出错，影响后续代码的执行 try 里面的代码如果都正确，catch里面的代码就不执行，否则catch里面的代码执行 123456789101112try &#123; console.log('a'); console.log(b); console.log('c'); // 到第二个console 的时候; 不执行，但是try外边的 "h" 依然被执行 &#125;catch (e) &#123; console.log(e); // catch 的作用就是把try里面的错误捕捉到， // 然后把（error.message error.name）封 // 装到一个error对象里面, 然后传给e，供我们使用&#125;console.log('h'); 在不知道后台传来data数据是否有错误的时候，这个是非常方便 Error.name 的六种值对应的信息1）EvalError : eval() 的使用与定义不一致 2）RangeError : 数值越界 3）ReferenceError : 非法或不能识别的引用数值 *** ​ 例如：未经声明就使用 4）SyntaxError : 发生语法解析错误 *** ​ 例如：出现中文符号 5）TypeError : 操作数据类型错误 ** 6）URLError : URL处理函数使用不当 ES5严格模式 目前我们使用的浏览器都是基于es3.0 的 + es5.0 的新增方法 使用的; 如果他俩产生冲突就会以es5.0为准, 否则使用es3.0， 定义为 “es5.0严格模式” 启动开关：”use strict”; 必须写在逻辑的最顶端； 12345"use strict";function test() &#123; console.log(arguments.callee) // 报错如下 caller一样&#125;// Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them 两种用法： 全局严格模式 局部函数内部严格模式 必须要在支持es5的浏览器上才可以 不支持with () {} 123456789101112131415161718var obj = &#123;name : "obj"&#125;;var name = 'window';function test() &#123; var name = 'scope'; width(obj) &#123; console.log(name); &#125; // with里面的代码会按照正常顺序执行， // 但是当with传一个对象后就发生了大变化， // 它会把这个对象当做with要执行的代码体的作用域链的最顶端； // 也就是会作用域链改变 // with跟命名空间配合使用，可以发挥很大的功效 width (document) &#123; write ('a') &#125; // 但是with 会更改作用域链，使代码运行效率变得非常慢&#125;test(); 变量赋值前必须声明 局部的this必须被赋值或者外部new，而且赋什么就是什么，否则指向空（undefined） （可以使用call / apply） 12345"use strict";funciton test() &#123; console.log(this); // 123&#125;test.call(123); 在非严格模式下，test.call(原始值)是坚决不行的，会给你包装成包装类Number {123} 全局下的console.log(this); 指向window； 拒绝重复的属性和参数，重复属性不报错，重复参数报错 不允许使用eval（）; 可以把字符串当成代码执行 1eval('console.log(123)'); // 123 可以改变作用域]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>try{}catch(e){}</tag>
        <tag>es5严格模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[数组 var arr = []; var arr = new Array() 这两种都是系统定义的，所以说数组能用的一切方法都来源于Array.prototype 这俩的唯一区别 12var arr = [10]; // [10] 推荐这种使用方法var arr1 = new Array(10); // [undefined*10] 长度为10的空数组，但是千万不能填小数 数组的读和写可以溢出读，溢出写 数组常用的方法改变原数组 push —— 在数组最后一位添加 123456Array.prototype.push = function () &#123; for (var i = 0; i &lt; arguments.length; i ++) &#123; this[this.length] = arguments[i] &#125; return this.length&#125; pop —— 从最后一位剪切出来（传参也没用） shift —— 从第一位添加 unshift —— 从第一位开始剪切（传参也没用） sort() 12var arr = [1, 7, 5, 10];arr.sort(); // [1, 10, 5, 7] 按照ASCll码排序（降序） 由于sort很大可能满足不了我们的开发需求，所以开发者特地给我们留了一个接口 供我们自己编写 123456789// 1 必须写俩形参// 2 看返回值// 1) 当返回值为负数时， 那么前面的数放在前面 小 - 大 &lt; 0// 2) 为正数时， 后面的数在前 大 - 小 &gt; 0// 3) 为0， 不动arr.sort(function (a, b) &#123; // return b - a;降序 return a - b; // 升序&#125;) 12345// 给一个有序的数组乱序var arr = [1, 2, 3, 4, 5, 6, 7];arr.sort(function () &#123; return Math.random() - 0.5;&#125;) reverse ——原数组逆转 splice —— 切片 123456var arr = [1, 2, 3, 4];// arr.splice(从地位开始, 截取多少长度, 在切口出添加新的数据) 还会返回截取出的数据console.log(arr.splice(1, 2, 5)) // (2)[1, 2] (3)[1, 5, 4]arr.splice(3, 0, 'haha') // [] (4) [1, 5, 4, "haha"]arr.splice(-1, 1) // 截取的是倒数第一位// 就是 -1 + arr.length 不改变原数组 concat ——连接 123var arr = [1, 2, 3];var arr1 = [6, 7, 8];arr.concat(arr1); // [1, 2, 3, 6, 7, 8] join 12var arr = [1, 2, 3];arr.join("-"); // "1-2-3"; 最好还是填字符串，当然原始值都可以 split 123var str = "1-2-3-4-5";str.split("-");// ["1", "2", "3", "4", "5"]; toString 12var arr = [1, 2, 3];arr.toString(); // "1, 2, 3" slice 1234var arr = [1, 3, 4];var newArr= arr.slice(1, 3); // [3, 4]// slice(从该位开始截取，截取到该位), 不写参数就全截取 类数组 属相为索引（数字）属性 必须要有lenngth属性 最好加上push 123456789101112131415var obj = &#123; "0" : 'a', "1" : 'b', "2" : 'c', "length" : 3, "push" : Array.prototype.push, "splice" : Array.prototype.splice // 当我们加上splice后 ["a", "b", "c", push: ƒ, splice: ƒ] 就变成这样了&#125;// 里面的push会有这样一个操作Array.prototype.push = function (target) &#123; obj[obj.length] = target; obj.length ++;&#125; 12345678910var obj = &#123; "2" : 'a', "3" : 'b', "length" : 2, "push" : Array.prototype.push&#125;console.log(obj); // &#123;2: "a", 3: "b", length: 2, push: ƒ&#125;obj.push('c');obj.push('d'); console.log(obj); // &#123;2: "c", 3: "d", length: 4, push: ƒ&#125; 123function test() &#123; console.log(typeof arguments); // object&#125; 12345var h = function a() &#123; return 23;&#125;console.log(typeof a());// error : a is not defined 判断引用值的类型 1234567891011121314151617181920212223// 1. 分两类 原始值 引用值// 2. 区分引用值function type(target) &#123; var ret = typeof(target); var template = &#123; "[object Array]":"array", "[object Object]":"object", "[object Number]":"number-object", "[object Boolean]":"boolean-object", "[object String]":"string-object" &#125; if(target === null)&#123; return "null"; &#125; if(ret == "object")&#123; // 数组 对象 包装类（Object.prototype.toString） var str = Object.prototype.toString.call(target); return template[str]; &#125;else&#123; return ret; &#125;&#125; 数组去重 123456789101112Array.prototype.unique = function() &#123; var temp = &#123;&#125;, arr = [], len = this.length; for (var i = 0; i &lt; len; i ++) &#123; if(!temp[this[i]])&#123; temp[this[i]] = "abc"; arr.push(this[i]) &#125; &#125; return arr;&#125; 优化以下代码 123456789101112131415161718192021222324252627282930313233343536function getDay(day) &#123; switch(day) &#123; case 1 : document.write("Monday"); break; case 2 : document.write("Tuesday"); break; case 3 : document.write("Wednesday"); break; case 4 : document.write("Thursday"); break; case 5 : document.write("Friday"); break; case 6 : document.write("Saturday"); break; case 7 : document.write("Sunday"); break; &#125;&#125;function retDay(day) &#123; var arr = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']; var ret = arr[day - 1]; if(ret === undefined) &#123; return 'error'; &#125;else &#123; return ret; &#125;&#125; retDay(7)]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>数组</tag>
        <tag>类数组</tag>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剖析this]]></title>
    <url>%2F2019%2F07%2F08%2Fthis%2F</url>
    <content type="text"><![CDATA[剖析thisthis的指向有哪几种情况？this代表函数调用相关联的对象，通常页称之为执行上下文。 12345678910111. 作为函数直接调用，非严格模式下，this指向window，全局作用域的this指向window。严格模式下，this指向undefined。2. 函数预编译过程中，this指向window。3. 作为某对象的方法调用，this通常指向调用的对象。4. 使用apply、call、bind 可以绑定this的指向。5. 在构造函数中，this指向新创建的对象6. 箭头函数没有单独的this值，this在箭头函数创建时确定，它与声明所在的上下文相同。 如果对一个函数进行多次 bind，那么上下文会是什么呢？123let a = &#123;&#125;let fn = function () &#123; console.log(this) &#125;fn.bind().bind(a)() // =&gt; window 不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。 1234567// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function() &#123; return fn.apply() &#125;.apply(a)&#125;fn2() 多个this规则出现时，this最终指向哪里？首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，es6中箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。 箭头函数 =&gt; 中this箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this 123456789101112131415161718192021222324var name = "222";var a = &#123; name : "111", say : function () &#123; console.log(this.name); &#125;&#125;var fun = a.say;fun(); // "222" 在全局window上执行a.say(); // "111"var b = &#123; name : "333", say : function (fun) &#123; fun(); // 没人调用，走预编译环节，在window执行 /* say : function () &#123; console.log(this.name); &#125;执行 */ &#125;&#125;b.say(a.say); // "222"b.say = a.say;b.say(); // "333" arguments在”use strict”中这俩家伙不让用 arguments.callee 1234567891011var test = function () &#123; console.log(arguments.callee) // ƒ () &#123;console.log(arguments.callee)&#125; // 指向函数自身引用&#125;var num = (function (n) &#123; if (n == 1) &#123; return 1; &#125; return n * arguments.callee(n - 1);&#125;(5)) fun.caller( 函数自己的属性 ) 12345678910111213141516// arguments上只有 callee 和length, symbol, __proto__ function test() &#123; demo(); console.log(arguments); // 如下图&#125;function demo() &#123; console.log(demo.caller);// demo 被调用的那个环境 /* 打印结果： ƒ test() &#123; demo(); console.log(arguments); &#125; */&#125;test(); 1234567891011121314151617181920212223242526272829303132333435363738394041421.var foo = "123";function print() &#123; var foo = "456"; this.foo = "789" console.log(foo);&#125;print(); // 456var foo = 123;function print() &#123; this.foo = 234; console.log(foo); console.log(this); // print &#123;foo: 234&#125;&#125;// print(); // 234new print(); // 123// var this = Object.creat(print.prototype); this里面没有foo属性var a = 5;function test() &#123; // var this = &#123; // 里面没a // __proto__ : test.prototype //&#125; a = 0; alert(a); alert(this.a); var a; alert(a);&#125;test();// 0 5 0new test(); // 0 undefined 0/*AO &#123; a : 0, this : &#123;&#125;&#125;*/ 2. 123456function print() &#123; console.log(foo);//undefined var foo = 2; console.log(foo);//2 console.log(hello);//报错：hello is not defined&#125; 3. 12345678function print() &#123; var test; // 被覆盖 test(); function test() &#123; console.log(1); &#125;&#125;print(); // 1 4 . 123456function print() &#123; var x = 1; if (x == "1") &#123;console.log("one")&#125;; if (x === "2") &#123;console.log("two")&#125;;&#125;print();//one 5. 1234567891011121314151617function print() &#123; var marty = &#123; name : "marty", printName : function () &#123;console.log(this.name)&#125; &#125; var test1 = &#123;name : "test1"&#125;; var test2 = &#123;name : "test2"&#125;; var test3 = &#123;name : "test3"&#125;; test3.printName = marty.printName; var printName2 = marty.printName.bind(&#123;name : 123&#125;); marty.printName.call(test1); // test1 marty.printName.apply(test2); // test2 marty.printName(); // marty printName2(); // 123 test3.printName(); // test3&#125;print(); 6 . 12345678910var bar = &#123;a : &quot;002&quot;&#125;;function print() &#123; bar.a = &apos;a&apos;; // 覆盖002 Object.prototype.b = &apos;b&apos;; return function inner() &#123; console.log(bar.a); console.log(bar.b); // 上原型链找 &#125;&#125;print()(); // a b 克隆 浅层 1234567891011121314var obj = &#123; name : 'abc', age : 123, sex : 'male'&#125;var obj1 = &#123;&#125;;function clone(origin, target) &#123; var target = target || &#123;&#125;; for (var prop in origin) &#123; target[prop] = origin[prop] &#125; return target;&#125;clone(obj, obj1); 深层(只考虑数组、对象) 12345678910111213141516171819202122232425262728293031323334353637383940var obj = &#123; name : "huang", age : 123, card : ['visa','master',123], wife : &#123; name : "bcd" son : &#123; name : 'faf' &#125; &#125;&#125;;var obj1 = &#123;&#125;;// 1遍历对象 for (var prop in obj)// 2判断是否原始值 typeof() object instanceof toString(万无一失) constructor// 3判断是数组还是对象// 4建立相应的数组和对象// 5递归function deepClone(origin, target) &#123; var target = target || &#123;&#125;, toStr = Object.prototype.toString, arrStr = "[object Array]"; // "[object Object]" 反正俩个其中一个 // 1 for(var prop in origin)&#123; // 2 if(origin.hasOwnProperty(prop)) &#123; if(origin[prop] !== "null" &amp;&amp; typeof(origin[prop]) == 'object') &#123; target[prop] = toStr.call(origin[prop]) == arrStr ? [] : &#123;&#125;; deepClone(origin[prop],target[prop]); // 如果里面还有引用值，再来 // 引用值处理 &#125;else&#123; target[prop] = origin[prop]; // 原始值处理 &#125; &#125; &#125; return target;&#125;deepClone(obj, obj1) 三目运算符 1234567891011var num = 1 &gt; 0 ? ("10" &gt; "9" ? 1 : 0) : 2;if (1 &gt; 0) &#123; var = num; if ("10" &gt; "9") &#123; return num = 1 &#125;else &#123; return num = 0 &#125;&#125;else &#123; return num = 2&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>this</tag>
        <tag>克隆</tag>
        <tag>三目运算符</tag>
        <tag>arguments</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[继承模式，命名空间，对象枚举]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[继承模式，命名空间，对象枚举继承模式 传统模式——&gt; 原型链（prototype） 过多的继承了没用的属性 借用构造函数（call / apply） 不能继承借用构造函数的原型 每次构造函数夺多走一个函数 共享原型（） 不能随意改动自己的原型 12345678910111213141516171819Father.prototype.lastname = "huang";function Father() &#123;&#125;function Son() &#123;&#125;Son.prototype = Father.prototypevar son = new Son();console.log(son.lastname); // huang// extend inherit（继承）// 封装继承方法Father.prototype.lastname = "huang";function Father() &#123;&#125;function Son() &#123;&#125;function inherit(Target, Origin) &#123; Target.prototype = Origin.prototype;&#125;inherit(Son, Father);// 这样不好，因为如果要给son单独添加一个属性的时候，将会同时给Father加上属性var son = new Son();// 于是就出现了圣杯模式 圣杯模式（加一个中介） 12345678910111213141516171819202122232425262728293031323334353637Father.prototype.lastname = "huang";function Father() &#123;&#125;function Son() &#123;&#125;function inherit(Target, Origin) &#123; function F() &#123;&#125;; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target;// *让constuctor指向目标对象 Target.prototype.uber = Origin.prototype; //*找到自己的超级父级，最终继承自谁&#125;inherit(Son, Father);var son = new Son();var father = new Father();Son.prototype.sex = "male";console.log(son.sex, father.ser); // male undefined/*我们还可以在丰满一下son.__proto__ --&gt; new F().__proto__ --&gt; Father.prototype让constuctor指向目标对象(如上面注释的有*两行)*/// 雅虎YUI3库的圣杯模式var inherit = (function () &#123; var F = function () &#123;&#125;; return function (Target, Origin) &#123; F.prototype = Origin.prototype; Target.prototype = new F(); Target.prototype.constuctor = Target; Target.prototype.uber = Origin.prototype; &#125;&#125;())// 闭包的第三作用：函数封装私有化/*F 被储存在return的函数的执行期上下文里面，被有私有化了（隐藏了），因为F是过度的函数，所以这个私有化是很好的*/ 命名空间 管理变量，防止污染全局，适用于模块化开发 12345678910111213// 闭包第四点：模块化开发，防止变量污染全局var name = 'hhh';var init = (function () &#123; // 约定俗成的初始化函数 'init' var name = 'abc'; // 里面的name与外边的name不会有任何关系 function callName() &#123; console.log(name); &#125; return function () &#123; callName(); &#125;&#125;()) jquery链式调用原理 12345678910111213141516var hobby = &#123; smoking : function () &#123; console.log('爽'); console.log(this); // hobby return this; &#125;, drinking : function () &#123; console.log('更爽'); return this; &#125;, perming : function () &#123; console.log('走烫头去'); return this; &#125;&#125;hobby.smoking().drinking().perming(); 属性的表示方法 1234567891011var obj = &#123;name : 'a'&#125;// 访问name属性： obj.name === obj['name'],// 事实上我们 obj.name 的时候 系统会隐式调用 obj['name']var hobby = &#123; hobby1 : '喝酒', hobby2 : '烫头', hobby3 : '抽烟' hobbyFun : function (num) &#123; return this['hobby' + num] &#125;&#125; 对象的枚举（遍历）enumeration for in（for循环的简化版，对象有多少个属性，就循环多少圈） 12345678910111213var obj = &#123; name : 'hsz', age : 20, sex : 'male', height : 170, weight : 55&#125;for (var prop in obj) &#123; console.log(prop); // name age sex height weight(打印对象的属性名) console.log(obj.prop); // 打印对象的属性值？ 结果是undefined // 因为会隐式的调用obj['prop']而不是obj[prop] console.log(obj[prop]);// 打印对象的属性值&#125; hasOwnProperty 1234567891011121314151617181920212223242526272829var obj = &#123; name : 'hsz', age : 20, sex : 'male', height : 170, weight : 55 __proto__ : &#123; lastName : 'h' __proto__ : Object.prototype &#125;&#125;for (var prop in obj) &#123; if (obj.hasOwnProperty(prop)) &#123; // 一般这俩是成套存在的 /* 判断是否是自己的属性或者方法（排除原型），但是一旦到了Object.prototype, 就会放弃遍历了 */ console.log(obj[prop]); &#125; console.log(obj[prop]); /* 但是要注意，但凡是自己设置的属性，prop到哪都能给你遍历出来 比如 Object.prototype.abc = 'abc', 照样给你遍历出来， 但凡是系统自带的就遍历不出来 */ &#125; in 12// in 只能判断 能不能够访问到这个属性，不管这个属性在哪'height' in obj // 控制台中返回true instanceof A instanceof B 官方解释： A 对象是不是 B 构造函数构造出来的 真正的判断： *A 对象的原型链上** 有没有 B的原型 1234function Person() &#123;&#125;var person = new Person();console.log([] instanceof Array); // trueconsole.log(person instanceof Array); // false 123456789101112131 typeof 123; // "number"2 typeof function () &#123;&#125; // "function"3 typeof undefined; // "undefined"4 typeof &#123;&#125;; //"object"typeof null; //"object"typeof []; //"object"5 typeof true; // "boolean"6 typeof '123'; // "string" 123456789var x = 1;if (function f() &#123;&#125;) &#123; // （）会把function f() &#123;&#125; 变成表达式然后函数名 f 失去效用 x += typeof f;&#125;console.log(x); // "1undefined"parseInt('1a') == 1 // truetypeof parseInt('1a') // "number"]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>继承模式</tag>
        <tag>对象枚举</tag>
        <tag>圣杯模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call和apply实现]]></title>
    <url>%2F2019%2F07%2F08%2Fcall-apply%2F</url>
    <content type="text"><![CDATA[call和apply实现 相同点：*call 和apply *改变this指向 差异： 传参列表不同 call 需要把实参按照形参的个数传进去 apply 需要传一个arguments 优点：借用别人的工厂生产函数 12345678910111213141516171819202122// call的第一个参数是要改变的目标function Person1(name) &#123; this.name = name&#125;var obj = &#123;&#125;;person1.call(obj, "hsz"); // this就指向了objconsole.log(obj); // &#123;name: "hsz"&#125;function Person(name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex;&#125;function Student(name, age, sex, tel, grade) &#123; // var this = &#123;&#125;; 自己隐式地生成 Person.call(this, name, age, sex); // 借用别人的函数，实现自己的功能 // 再增加自己想要的属性、方法 this.tel = tel; this.grade = grade;&#125;var student = new Srudent("hsz", 123, "male", 139, 2019) call12345678910Function.prototype.newCall = function () &#123; var ctx = arguments[0] || window; ctx.fn = this; var args = []; for (var i = 1; i &lt; arguments.length; i++) &#123; args.push(`arguments[$&#123;i&#125;]`) &#125; return result = eval(`ctx.fn($&#123;args.join(',')&#125;)`); delete ctx.fn;&#125; eval();——会改变作用域，不好，但是这里为了实现 call功能，并没有其他影响join() 方法用于把数组中的所有元素放入一个字符串 apply123456789101112131415Function.prototype.newApply = function (ctx, arr) &#123; var ctx = ctx || window; ctx.fn = this; if (!arr) &#123; return result = ctx.fn(); delete ctx.fn; &#125;else &#123; var args = []; for (var i = 0; i &lt; arr.length; i++) &#123; args.push(`arr[$&#123;i&#125;]`) &#125; return result = eval(`ctx.fn($&#123;args.join(',')&#125;)`); delete ctx.fn; &#125;&#125;]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>call</tag>
        <tag>apply</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型，原型链]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型 定义： 原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该原型的属性和方法。原型也是对象。(类似遗传) obj.prototype ———— 原型 123456Person.prototype.name = "hsz";function Person() &#123; &#125;var person1 = new Person();console.log(person1.name); // "hsz" 利用原型特点和概念，可以提取共有属性。 1234567891011121314151617Car.prototype.name = "BMW";Car.prototype.height = 1400;Car.prototype.lang = 4900;// 这样的目的是消除代码耦合， 因为如果我new的次数多了，就会造成耦合度很高function Car(owner, color) &#123; this.owner = owner; this.color = color&#125;var car = new Car('red', 'prof.huang');car.name = 'zjx'; // Car &#123;owner: "red", color: "prof.huang", name: "zjx"&#125;// 想要改变原型链上的name属性只有 Car.prototype.name = "zjx";// 通过后代是改不了祖先的属性的// 增加属性也是要通过prototype// 删除属性： delate， 如果要删除祖先的属性一样要通过prototype去删除 对象如何查看原型 ——&gt; 隐式属性 __ proto __ 123456789101112131415161718// 尽量别修改的属性Person.prototype.name = 'abc';function Person() &#123; /* 每一个对象都有一个proto指向本身的prototype 比如找一个属性，如果自身找不到的话就会沿着__proto__ 的指向找 var this = &#123; __proto__ : Person.prototype &#125; 这个__proto__ 也是可以修改的 */ &#125;var obj = &#123;name : "happy"&#125;var person = new Person();person.__proto__ = obj;// 这是后person.__proto__ 就指向了 obj 而不是 Person 对象如何查看对象的构造函数 ——&gt; constructor 12345678910111213141516171819202122232425function Car(owner, color) &#123; this.owner = owner; this.color = color&#125;var car2 = new Car();Car.prototype.constructorcar2.constructor// 控制台中是这样的ƒ Car(owner, color) &#123; this.owner = owner; this.color = color&#125;// 这个constructor是可以人为改变的function Person() &#123;&#125;Car.prototype = &#123; constructor : Person&#125;var car2 = new Car();car2.constructor// 控制台中是这样的ƒ Person() &#123;&#125; 脑经急转弯 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Person.prototype.name = 'happy';function Person() &#123; // var this = &#123;__proto__ : Person.prototype&#125; // 现在__proto__ 和 Person.prototype 指向一个空间; // 即使 Person.prototype 指向了另一个空间, __proto__ 依然指向 "happy"&#125;var person = new Person();console.log(person.name); // happyPerson.prototype.name = 'hsz' // 覆盖了原来的namePerson.prototype = &#123; name : 'xiuxiu' // 这相当于存到了另一个堆里面，相当于换血了 /* 同理如下： var obj = &#123;name : "a"&#125;; var obj1 = obj; obj = &#123;name : "b"&#125; obj1.name == "a" obj.name == "b" obj1 ==&gt; obj ==&gt; name: "a" 然后：obj1 ==&gt; name : "a", obj ==&gt; name : "b" __proto__ ==&gt; Person.prototype ==&gt; "hsz" 同理然后：__proto__ ==&gt; "hsz", Person.prototype ==&gt; "xiuxiu" */&#125;console.log(person.name); // hsz// 那么我们再来看另一种情况Person.prototype.name = 'happy';function Person2() &#123;&#125;Person.prototype = &#123; name : 'xiuxiu'&#125;var person2 = new Person2();console.log(person2.name); // xiuxiu/*这就需要考虑预编译环节了 function Person2() &#123;&#125; 首先函数声明提升 Person.prototype.name = 'happy'; 然后执行这一句 Person.prototype = &#123; name : 'xiuxiu' 然后执行这一句 &#125; var person2 = new Person2(); 当new的时候，函数才发生改变，这个时候name已经被覆盖了 上一次是应为函数已经new了，才改变name的，所以两次结果不一样。顺序有时候也很关键*/ 原型链 原型链的连接点就是 __ proto__ 原型链的访问方式跟作用域链的访问方式雷同，都是先往内部找，找不到再找远处 1234567Grand.prototype.name = "hsz"function Grand() &#123;&#125;var grand = new Grand();/*Grand.prototype.__proto__ = Object.prototypeObject.prototype 是所有原型链的终端*/ 原型链上的增、删、改、查 只能通过自己增、删、改、查，后代是无法进行这些操作的 1234567891011121314151617Person.prototype = &#123; name : "a", num : 10, sayname : function () &#123; console.log(this.name); &#125;&#125;function Person() &#123; this.name = "b";&#125;var person = new Person();person.num++/*当调用person.num++后，就有了num属性Person &#123;name: "b", num: 12&#125;就像复制了一样，后面会说克隆，有异曲同工的效果*/ Object.create(原型)——更加灵活的创建对象的方法 1234567var obj = &#123;name : "hsz", age : 123&#125;;var obj1 = Object.create(obj);Person.prototype.name = "hsz";function Person() &#123;&#125;var person = Object.create(Person.prototype); 绝大多数的对象的最终都会继承自Object.prototype 1234567var obj = Object.create(null); // 这个就没原型 only object and null// 即使人为的加了__proto__, 系统一样读不了obj.__proto__ = &#123;name : "hsz"&#125;console.log(obj.name); // undefined// undefined and null 没有原型所以 .toString(); 会报错123.toString(); // 报错，因为 123. 会被系统认为是浮点型 1234567891011121314151617181920212223242526var num = 123;num.toStrng(); // "123"// 在Number的prototype上有很多方法其中有toStringNumber.prototype.toString = function () &#123; // 这就叫方法的重写 // 所以事实上我们调用的是Number.prototype上它自己重写的toString方法&#125;// 如果我们调用的是Object.prototype.toString方法的话，结果就不是"123"了Object.prototype.toString.call(123); // "[Object Number]"var obj = &#123;&#125;;obj.toString(); // "[object Object]"var obj1 = Object.create(null);document.write(obj); // 报错// 事实上我们打印的是这个： document.write(obj.toString()),// 下面我们来验证是否真的调用了toString方法var obj1 = Object.create(null);obj1.toString = function () &#123; return "哈哈哈"&#125;document.write(obj1); // "哈哈哈" 小bug 12345javascript的小数多少有些偏差0.14 * 100 // 14.000000000000002// 所以尽量别用toFix()// 小数点后可以操作18位以上了，已经会用科学计数法表示了// 可以正常计算的范围内： 小数点前16位，后16位 是可以计算准确的]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象_包装类]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%AF%B9%E8%B1%A1_%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对象、包装类 对象可以放属性，函数，需要设置属性名，属性值 12345678910111213141516var hsz = &#123; name: "hsz", age: 23, sex: "male", smoke: function () &#123; console.log("cool!!!"); this.health --; &#125;, drink: function () &#123; console.log("so cool!!"); this.health ++; &#125;, health: 100&#125;// 这里的函数与普通的函数一样可以传参数等操作// 如果把一个对象当成一个人的话，health 会称为这个人的健康（this），而不是hsz的health 属性的增、删、改、查123456hsz.girlFriend = "xiangZhang"; // 增hsz.girlFriend; // 查hsz.girlFriend = "xiuxiu" // 改delate hsz.health // 删// 当一个变量未声明就输出会报错，但是一个对象里的属性没添加，不会报错，打印undefined 对象的创建方法 var obj = {} plainObject 对象字面量、对象直接量 构造函数 1) 系统自带构造函数 Object() 123var obj = new Objectvar obj = &#123;&#125;// 这两者是没有任何区别的，除了视觉上 2) 自定义( 构造函数 ) 1234567891011121314151617181920/* 由于函数与构造函数视觉上没有区别，为了小伙伴们更好的区分，就产生了大驼峰式命名即首字母大写*/function Car(color) &#123; this.color = color, // 通过参数改变颜色，让构造函数变得更强大 this.name = "BMW", this.height = "1400", this.lang = "4900", this.width = 1000, this.health = 100, this.run = function () &#123; this.health --; &#125; // 将所有需要批量制造的事物定义好，&#125;// 但是必须借助一个工具 newvar car1 = new Car('red'); // 这就生产出来了一辆与 原始Car 一样的 car1 了car.name = "Maserati" // 然后再改变成自己想要的 玛莎拉蒂 123456789101112131415161718192021function Student(name, age) &#123; /* 1.在new的过程中，内部会隐式地： var this = &#123; &#125;; 2.往this这个对象添加属性 this = &#123; name: "", age: &#125; */ this.name = name, this.age = age /* 3.最后： return this; 只能return 一个对象，其他的都不行 */&#125;var student = new Student('hsz', 18) ### 包装类 1234var num = new Number(123); // Number 型对象var str = new String('abc'); // String 型对象var bol = new Boolean('true') // Boolean 型对象 // 事实上也就是个对象 ##### 原始值是坚决不能有属性和方法的，但是为什么这种操作，又不报错呢 123456789101112var num = 4;/*(隐式地) new Number(4)（然后） Number(4).len = 3(再然后) delate —— 销毁 new Number(4).len = 3;(再然后) new Number(4).len ———— 这是一个系统给你新new的Number(最后打印) undefined*/num.len = 3;console.log(num.len); // undefinedconsole.log(num); // 4 —— num依然存在，销毁的不是num ##### 我们再来看这个特殊的家伙 123456789101112var str = 'abcd';str.length = 2;console.log(str); // 'abcd'console.log(str.length); // 4 ———— 蒙了吧/*(隐式地) new String('abcd')（然后） String('abcd').len = 3(再然后) delate —— 销毁 new String('abcd').len = 3;(最后打印) str == 'abcd', str.length == 4;new String('abcd').length 是系统自带的 ———— 这是一个很特殊的*/ ##### Boolean 和 string new 完了后可以像object一样添加自己的属性 1234567891011var str = new String('abcd');str.a = 'bcd';str.b = function () &#123; console.log(this.a) &#125;console.log(str) // String &#123;"abcd", a: "bcd", b: ƒ&#125;console.log(str.length) // 4var boo = new Boolean('abcd');boo.a = 'bcd';boo.b = function () &#123; console.log(this.a) &#125;console.log(boo); //Boolean &#123;true, a: "bcd", b: ƒ&#125;console.log(Boolean.length) // 1 ##### 例子 12345678var str = "abc";str += 1; // "abc1"var test = typeof(str); // "string"if (test.length == 6) &#123; test.sign = "typeof的返回结果可能是String"&#125;console.log(test.sign);// undefined// 这出题人真会折磨人 1234567891011var x = 1, y = z = 0;function add(n) &#123; return n = n + 1;&#125;y = add (x);function add(n) &#123; return n = n + 1;&#125;z = add(x)// x = 1, y = 4, z = 4; // 函数声明提升， add覆盖（视觉上懵人） Object.create() 1var a = Object.create(null) // 返回为null的空对象，啥都没有 除此之外，没啥区别了]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>对象</tag>
        <tag>包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数_作用域链]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%87%BD%E6%95%B0_%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[函数作用域链 函数函数声明高内聚， 低耦合 命名规范：小驼峰式命名 123451. 命名函数表达式function theFirstFun() &#123; console.log('abc');&#125;theFirstFun.name // theFirstFun ​ 表达式类函数，忽略函数名, 此时 abc 被忽略 1234562. 匿名函数表达式 ———— 后来叫做函数表达式var test = function abc() &#123; console.log('abc')&#125;test();test.name // abc 函数传参 12345678910111213141516171819202122232425262728293031323334// 形参 ———— delete 删除不了function sum(a, b) &#123; console.log(sum.length) // 2 形参长度 console.log(arguments.length) // 3 实参长度 // 等同于在函数内部声明了 a, b var c = a + b; coonsole.log(c) // 每个函数在出生的时候系统就会隐式地创建一个arguments（类数组）来装实参——实参列表&#125;// 实参sum(1, 2, 3)function sum1(a, b, c) &#123; // 现在的情况是 // var a = 1; // var b = 2; // var c; // arguments =&gt; [1, 2] 实参只有 2 位 // 然后我们改变规则 a = 10; console.log(arguments[0]); // 10 // 我们再改变一次 arguments[0] = 20; console.log(a); // 20 // 我们会发现这中间存在映射规则 实参的每一位对应形参的每一位 c = 30; console.log(arguments[2]); // undifined; // 所以得出 实参出生的时候有几个 就是几个&#125;sum1(1, 2); 函数的 return 值函数的结束条件 + 返回值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function sum(a) &#123; console.log(a); return '123'; // 有中断 并且 返回值 结束的功能, 不会打印下面的20 console.log(20); // 2 &#125;sum(2);// 123 倒叙且变中文function reverse() &#123; var num = window.prompt('input'); var str = ""; for (var i = num.length - 1; i &gt;= 0; i --) &#123; // 倒着加 2 =》 1 =》 0 str += transfer(num[i]); &#125; console.log(str);&#125;function transfer(target) &#123; switch (target) &#123; case "1": return "壹"； case "2": return "俩" case "3": return "仨" &#125;&#125;// 阶乘// 递归 —— 唯一好处，简洁代码function jc(n) &#123; if (n == 1 || n == 0) &#123; return 1; // 出口， 不然就在无穷死循环 &#125; return n * jc(n-1)&#125;// 1. 找规律// 2. 找出口// 斐波那契数列 fn(n) == fb(n - 1) + fb(n -2)function fb(n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return fb(n - 1) + fb(n - 2);&#125; 作用域初探JS运行分三步：语法分析（通篇扫描是否有语法错误），预编译（发生在函数执行的前一刻），解释执行（一行行执行）。 全局变量：在函数外声明的变量 局部变量：在一个区域内声明的变量预编译 imply global 暗示全局变量：即任何变量，如果变量未经声明就赋值，此变量归全局所有。 a = 123; 一切声明的全局变量，全是window的属性。window就是全局的域 1234var a = 123;console.log(window.a); // 123// 等同于：window &#123;a : 123&#125; 函数预编译四部曲 123456789101112131415fn(1);function fn() &#123;console.log(a); // ƒ a() &#123;&#125; var a = 123; // 提升到第 2 位 覆盖第一个 a console.log(a); // 123 function a() &#123;&#125;; // 提升到第 1 位 console.log(a); // 123 var b = function () &#123;&#125;// 提升到第 2 位 console.log(b); // ƒ () &#123;&#125; function d() &#123;&#125; // 提升到第 1 位&#125; 创建AO对象 (action object 由于这个函数而产生的存储空间库) 1AO &#123;&#125; 找形参和变量声明，将变量和形参名作为AO的属性名，值为undefined 12345678AO &#123; // arguments : [1], // this : window, // 这里还有两步，这里为了方便，先注释，不考虑。 a : undefined, b : undefined,&#125; 将实参值和形参统一 12345AO &#123; a: 1, b: function () &#123;&#125;, // 形参没有对应的实参就不用管&#125; 在函数体里面找函数声明， 值赋予函数体 *（函数表达式提升不了，它是表达式） 123456789101112AO &#123; a: function a() &#123;&#125;,// 覆盖了形参的a b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;=====&gt;AO &#123; a: 123, // 执行完第一个console.log后，a再度覆盖fn b: function () &#123;&#125;, d: function d() &#123;&#125;&#125;// 一句一句执行 例子2： 12345678910111213141516171819202122232425262728293031323334353637383940function test(a, b) &#123; console.log(a); c = 0; var c; a = 3; b = 2; console.log(b); function b() &#123;&#125; function d() &#123;&#125; console.log(b);&#125;test(1);/*1. AO &#123;&#125;2. AO &#123; a: undefined, b: undefined,&#125;3. AO &#123; a: 1, b: undefined,&#125;4. AO &#123; a: 1, b: function b() &#123;&#125;, d: function d() &#123;&#125;&#125;所以第一个console.log(a) =&gt; 1然后继续AO &#123; a: 3, b: 2, c: 0, d: function d() &#123;&#125;&#125;所以后面两个console.log(b) 都是 2*/(window.foo || (window.foo = 'bar'));// bar 全局：global object( GO ) GO === window 作用域，作用域链函数作用域[[scope]] [[scope]] : 每个javascript函数都是一个对象，对象中有的属性可以访问，有的不能，这些属性仅供javascript引擎存取，[[scope]] 就是其中一个。[[scope]] 指的就是函数的作用域，其中存储了执行期上下文的集合。 执行期上下文： 当函数执行前一刻，会创建一个称为执行期上下文的内部对象（AO）。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时对应的执行期上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行期上下文，当函数执行完毕，它所产生的执行上下文被销毁。 作用域链 [[scope]]中所存储的执行期上下文对象的集合，这个集合呈链式链接，我们称这种链式链接为作用域链。查找变量时，要从作用域链的顶部开始查找。Activation Object（AO）到Global Object（GO）。 查找变量： 从作用域链的顶端依次向下查找 1234567891011121314151617181920function a() &#123; function b() &#123; var bb =234; &#125; var aa = 123; b();&#125;var glob = 100;a();// a defined(定义) a.[[scope]] --&gt; 0 : GO// a doing(执行) a.[[scope]] --&gt; 0 : a-AO// 1 : GO// b defined(定义) b.[[scope]] --&gt; 0 : a-AO// 1 : GO// b doing(执行) b.[[scope]] --&gt; 0 : b-AO// 1 : a-AO// 2 : GO 闭包1 当内部函数被保存到外部时，将会生成闭包。生成闭包后，内部函数依旧可以访问其所在的外部函数的变量。 危害：闭包会导致原有作用于连不释放，造成内存泄漏（占的多了，剩的就少了） 闭包问题的解决方法：立即执行函数、let 详细解释： 当函数执行时，会创建一个称为执行期上下文的内部对象（AO），执行期上下文定义了一个函数执行时的环境。 函数还会获得它所在作用域的作用域链，是存储函数能够访问的所有执行期上下文对象的集合，即这个函数中能够访问到的东西都是沿着作用域链向上查找直到全局作用域。 函数每次执行时对应的执行期上下文都是独一无二的，当函数执行完毕，函数都会失去对这个作用域链的引用，JS的垃圾回收机制是采用引用计数策略，如果一块内存不再被引用了那么这块内存就会被释放。 但是，当闭包存在时，即内部函数保留了对外部变量的引用时，这个作用域链就不会被销毁，此时内部函数依旧可以访问其所在的外部函数的变量，这就是闭包。 1234567891011121314151617function a() &#123; function b() &#123; var bbb = 234; console.log(aaa); &#125; var aaa = 123; return b;&#125;var glob = 100;var demo = a();demo(); // 123/*f b() &#123;&#125; 被保存出来了并且赋给了demo虽然return后 a 的执行期上下文被销毁，但是b函数[[scope]]=&gt; aAO, bAO, GO所以顺着链找就可以找到 ‘var aaa = 123;'*/ 12345678910111213141516// 闭包作用于累加function a() &#123; var num = 100; function b() &#123; num ++; console.log(num); &#125; return b;&#125;var demo = a();demo(); // 101demo(); // 102/*第二个为啥是102 呢？第一次demo执行完了后，a的AO依然被销毁，但是b的[[scope]]里面存的是第一次demo();后的aAO，事实上就是a斩断了aAO的线，想要销毁，但是b的手里撰着aAO，所以第一次执行产生的aAO，GO被永远当成了基础来用了;*/ 1234567891011121314151617// 闭包作用于缓存（储存结构）function test() &#123; var num = 100; function a() &#123; num ++; cosole.log(num); &#125; function b() &#123; num --; console.log(num); &#125; return [a, b];&#125;var myArr = test();myArr[0](); // 101myArr[1](); // 100// 被保存出来的f a() &#123;&#125; 和 f b() &#123;&#125; 共用一个testAO 立即执行函数 函数出生的时候都是等待被执行的，这个过程是很占内存的，尤其是那些只被执行一次就销毁的函数, 所以有了立即执行函数，执行完就被销毁，这是跟普通函数的唯一区别，其他一样，有执行期上下文，可以传参等等 针对初始化功能的函数 1234567891011121314(function () &#123;&#125;()); // W3C 建议第一种(function () &#123;&#125;)();var test = function () &#123; console.log(123);&#125;();+ function test() &#123;&#125;();- function test() &#123;&#125;();! function test() &#123;&#125;();// 陷阱function test(a, b, c, d) &#123; console.log(a, b, c, d)&#125;(1, 2, 3, 4);// 比报错也不执行 闭包2 针对for循环 123456789101112131415161718function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + " "); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;// 10个10/*我们只看第一个for循环， 因为第二个只是为了执行在for循环中 i 是不停在变的，我们要知道，函数只有在执行的时候才会被读取语句，当return完的时候，test函数才执行结束，而此时所有return出来的函数用的都是 test的AO，并且这个testAO里面for循环出来的i已经变成 10 了，当我们执行 myArr 的时候，用的就是 i = 10*/ 解决办法 1234567891011121314// (es6) letfunction test() &#123; var arr = []; for (let i = 0; i &lt; 10; i ++) &#123; arr[i] = function () &#123; document.write(i + " "); &#125; &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125; 1234567891011121314151617181920212223242526272829303132333435function test() &#123; var arr = []; for (var i = 0; i &lt; 10; i ++) &#123; (function (j) &#123; arr[j] = function () &#123; document.write(j + " "); &#125; &#125;(i)) &#125; return arr;&#125;var myArr = test();for (var j = 0; j &lt; 10; j ++) &#123; myArr[j]();&#125;/*在for循环中：(function (0) &#123; // j = 0 arr[0] = function () &#123; document.write(j + " "); &#125;&#125;(0)) // ———— 马上执行，然后将arr[0]丢到test的arr里面，等待被return出去,// 此时立即执行函数的AO依然被arr[0]这个函数保存在arr[0]的[[scope]]里 (function (1) &#123; // j = 1 arr[1] = function () &#123; document.write(j + " "); &#125;&#125;(1)) // ———— 马上执行，然后将arr[1]丢到test的arr里面，等待被return出去................*/ 1234567891011121314151617181920212223function test () &#123; var food = "apple"; var obj = &#123; eatFood : function () &#123; if (food != "") &#123; console.log("I am eating " + food); food = ""; &#125;else &#123; console.log("There is nothing!"); &#125; &#125;, pushFood: function (myFood) &#123; food = myFood &#125; &#125; return obj;&#125;var person = test();person.eatFood(); // I am eating appleperson.eatFood(); // There is nothing!person.pushFood('banana'); person.eatFood(); // I am eating banana// 大家保存的都是同一个域，所以公用food这个变量（缓存） 12345678910111213141516171819202122&lt;!-- 阿里巴巴uc事业社招笔试题 --&gt;&lt;!--使用原生js，addEventListener，给每个li元素绑定一个click事件，输出他们的顺序--&gt;&lt;ul&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;a&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; window.onload = function () &#123; var ulList = document.getElementsByTagName('ul')[0]; var liList = ulList.getElementsByTagName('li'); for (var i = 0; i &lt; liList.length; i++) &#123; (function (j) &#123; liList[j].addEventListener('click', function (j) &#123; console.log(j) &#125;) &#125;(i)) &#125; &#125; // 同样可以用let解决&lt;/script&gt; 1234567891011121314151617/* 腾讯微店写一个方法，求一个字符串的字节长度提示： charCodeAt(); 一个中文占两个字节, 一个英文占两个字节, charCodeAt()方法可返回置顶位置的字符得到Unicode编码，这个返回值是0-65535之间的整数当返回值是 &lt;= 255时为英文（占1个字节）, 当返回值 &gt; 255 时为中文（占2个字节）*/ function retByteslen(target) &#123; var count, len; count = len = target.length; for (var i = 0; i &lt; len; i++) &#123; if (target.charCodeAt(i) &gt; 255) &#123; count ++; &#125; &#125; console.log(count);&#125; 逗号表达式 12345678910111213141516171819202122232425var a = (1 - 1, 1 + 1, 2 + 5);console.log(a); // 7// 一定要用括号括起来， 括号里面需要计算的先计算，，最后返回最后一个的计算结果var f = (function f() &#123; return "1"; &#125;,function g() &#123; return 2 &#125;)();console.log(typeof(f)) // numbervar x = 1;if (function f() &#123;&#125;) &#123; // (function f() &#123;&#125;) ==&gt; 被括号变成了表达式，函数名被忽略了 x += typeof f;&#125;console.log(x); // "1undefined"// 阿里巴巴UC社招笔试题： body 插入 一个div（原生js）var oDiv = document.createElement('div');var body = document.getElementsByTagName('body')[0];body.appendChild(oDiv);]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>函数</tag>
        <tag>预编译</tag>
        <tag>作用域链</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js简介]]></title>
    <url>%2F2019%2F07%2F08%2Fjs%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[js —— Javascript：解释性语言 js ——JavaScript：解释性语言同时也叫 ECMAScript 编译 C，C++等 ​ 优点：快 ​ 不足：移植性不好，(不跨平台) 解释 javascrip， php等 ​ 优点：跨平台（不需要编译成文件） ​ 不足：稍慢 混合型 Java ​ .java –&gt;javac –&gt; 编译 –&gt; .class —-&gt; jvm —-&gt; 解释执行（两个都不是） 生活中的异步就是js的同步 单线程，同一时间处理一件事 那是怎么模拟成多线程呢？处理事件足够快的情况下，就可以做到看起来同时在做同一时间在做多件事 专业术语： 轮转时间片（争抢时间） 主流浏览器： ​ IE —————— trident ​ Chrom ———— webkit / blink ​ Firefox ———— Gecko ​ Opera ———— presto ​ Safari ———— webkit 引入js ​ 页面嵌入&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt; ​ 外部js文件&lt;script type=&quot;text/javascript&quot; src=&quot;./***.js&quot;&gt;&lt;/script&gt; ​ 为符合W3C标准 结构(html) 行为(js) 样式(css) 相分离 ​ 编程语言特点： 有变量( variable ) ​ html，css属于脚本语言，计算机语言( 依然不影响它们的强大 ) 变量声明 ​ var a;—— 向window申请一个地方叫a ​ 多个变量时尽量单一 var 123var a, b, c; 变量赋值 ​ a = 100;—— 把100给a ​ 再次赋值111给 a ，则原来100会被替换 变量命名规则 变量名必须以包括 英文字母，_ , $ 开头 变量名可以包括 英文字母， _ , $ 数字 不可以用系统关键字(var new break else等)， 保留字作为变量名 (float int long class等) 运算优先级 &gt; 赋值 值的类型 原始值 （stack）栈内存 first in, last out （不可改变性） ​ Number ———— 数字（1, 2, 3, 4） ​ Boolean ———— 布尔（true / false） ​ String ————— 字符串（’ 123 ‘， “ 123 “） ​ undefined ——— 没有定义的（undefined） ​ null —————— 空—–占位（null） 引用值（heap）堆内存 ​ Array ————— 数组（[1, 2, 3, 4]） ​ Object ———— 对象（{a: 1, b: 2}） ​ function ——— 函数（function () {}） ​ Data ————— Data（） ​ RegExp ———— 正则（//） Number、Stirng、Boolean、Null、Underfined这些基本数据类型，他们的值直接保存在栈中; 栈内存与栈内存之间是复制的关系var b = a; 12345678var num = 100;var num1 = num;num = 200；事实上 —— 100 依然存在，只是剪断了 num 与 100 的关系然后重新在 window 弄了个 num1 再然后将原来的 num值（100）赋给 num1，最后又重新找window要了个地方叫num，将原来的num地方抹去变量名，再把200赋值给num Object、Function、Array、Date、RegExp这些引用类型，他们的引用变量（地址）储存在栈中，通过指针（这个地址）指向储存在堆中的实际对象 对象 操作 Array 将 Array 的元素转换为字符串。结果字符串由逗号分隔，且连接起来。 Boolean 如果 Boolean 值是 true，则返回 “true”。否则，返回 “false”。 Date 返回日期的文字表示法。 Error 返回一个包含相关错误信息的字符串。 Function 返回如下格式的字符串，其中 functionname 是被调用 toString 方法函数的名称：function functionname( ) { [native code] } Number 返回数字的文字表示。 String 返回 String 对象的值。 默认 返回 “[object objectname]”，其中 objectname 是对象类型的名称。 123var arr = [1, 2];var arr1 = arr;arr.push(3); 123var arr = [1, 2];var arr1 = arr;arr = [1, 3]; js语句基本规则 语句后面加分号结束 “ ; “ js语法错误会引发后续代码终止，但不会影响其他js代码块 低级错误：（语法解析错误）出现中文符号等 逻辑错误：（标准错误， 情有可原）没有定义变量等 一个&lt;script type=&quot;text/javascript&quot;&gt;&lt;script/&gt;就是一个js代码块 书写格式要规范， “ = + / - “ 两遍呢都应该有空格 运算操作符 数学运算，字符串连接 任何数据类型加字符串都等于字符串 “ + “ , “ - “ , “ * “, “ / “ , “ % “ , “ () “ 优先级 “ = “ 最弱， “ () “ 最强 “ ++ “ , “ – “ , “ += “ , “-=” , “ /=” , “ *= “, “ %= “ 1234567891011121314151617181920212223242526272829303132// a++ ——&gt; a = a + 1var a = 10;console.log( a++ ); // 先打印a，再 ++ 10var b = 20;console.log( ++b ); // 先 ++ ，再打印a 21var num1 = 10;var num2 = ++num1 - 1 + num1++; // 但是工作这样写是不行的，要新人都可以看懂才好console.log(num2 + ' ' + num1); // 21 12 // num += 10; ——&gt; num = num + 10// 交换 n 和 m 的值var n = 123;var m = 234;1. var c = n; n = m; m = c;2. a = a + b; b = a - b; a = a - b;3. var a = 1 + 'a'; // 1a var b = 0 / 0; // NaN var c = 1 / 0; // infinity4. var a = 1; var b = ++a + 1; // 3 '++'第一运算 var c = a++ + 1; // 2 '++'最后才运算 比较运算符 “ &lt; “ , “ &gt; “ , “ = “ , “ &gt;= “ , “ &lt;= “ , “==” , “ != “ , “ === “ 字符串比较的是 ASCLL 码 123456var a = '10' &gt; '8'; // false&#123;&#125; == &#123;&#125;; // false[] == []; // falsenull == undefined; // true 逻辑运算符 “ &amp;&amp; “ , “ || “ , “ !“ —— 运算的结果为真实值 “ &amp;&amp; “ —— 表达式转换成布尔值的结果，如果结果为真，那么它会看第二个表达式转换为布尔值的结果，然后如果只有两个表达式的话，只要看到第二个表达式，就返回表达式的值了，简单来说：遇到为false的值返回 这个值，遇到全为true的值就返回 最后一个值, 有中断的作用，所以可以作为”如果，那么”: 12 &gt; 1 &amp;&amp; document.write('aaa') “ || “ —— 遇到为true的值返回 这个值，遇到全为false的值就返回 最后一个值 “! “ —— 转换为布尔值再取反， !!NaN转换为布尔值, 调用Boolean() undefined, null, NaN, “”, 0 —— 这五个值返回的布尔值都是FALSE 条件语句循环语句 if语句 —— 括号里的条件为true就运行 “{}” 里面的 1234567891011if (1 &gt; 0 &amp;&amp; 2 &gt; 0) &#123; console.log('a');&#125;if () &#123; &#125;else if () &#123; // 类似排除法 &#125;else &#123; &#125; for循环 12345678910111213141516171819202122232425262728for ( var i = 0; i &lt; 10; i++ ) &#123; // (1) —————（2）—————（3） // 减少我们的重复 console.log('a') // 打印10个a&#125;/* for 循环执行顺序： 先执行一遍（1） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 判断（2）执行语句 执行（3） 直到（2）有一次条件不成立，立马停止1. var i = 0;2. if (i &lt; 10) &#123; console.log('a')&#125;3. i++; ---&gt; i = 1;4. if (i &lt; 10) &#123; console.log('a')&#125;5. …………*/ while循环（简化版的for循环） 123456789101112var i = 0;/*for (;i &lt; 10;) &#123; console.log(i); i++;&#125;*/while (i &lt; 10) &#123; console.log(i); i++;&#125;// 两个一样的效果 练习： 计算2的n次幂，n可输入，n为自然数 1234567var n = parseInt(window.prompt('input'));var mul = 1;for (var i = 0; i &lt; n; i ++) &#123; mul *= 2;&#125;console.log(mul)// 先找规律，在写 计算n的阶乘，n可输入 1234567var n = parseInt(window.prompt('input'));// parseInt() 函数可解析一个字符串，并返回一个整数。var mul = 1;for (var i = 1; i &lt;= n; i ++) &#123; mul *= i;&#125;console.log(mul); 著名的斐波那契数列， 输出第n项 1234567891011121314var n = parseInt(window.prompt('input'));var first = 1, secend = 2, third;if (n &gt; 2) &#123; for (var i = 0; i &lt; n-2; i ++) &#123; third = first + secend; first = secend; secend = third; &#125; console.log(third);&#125;else &#123; console.log(1);&#125; 编写程序， 输入一个三位数的正整数， 输出时反向输出。如：456 —&gt; 654 1 输入a, b, c三个数字，打印出最大的 1234567891011121314var n = parseInt(window.prompt('input'));if (a &gt; b) &#123; if (a &gt; c) &#123; console.log(a) &#125;else &#123; console.log(c) &#125;&#125;else &#123; if (b &gt; c) &#123; console.log(b) &#125;else &#123; console.log(c) &#125;&#125; 打印出100以内的质数 123456789101112var count = 0;for (var i = 2; i &lt; 100; i++) &#123; for (var j = 1; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; count ++; &#125; &#125; if (count == 1) &#123; console.log(i + " ") &#125; count = 0;&#125; switch case， break， continue1234567891011121314var data = window.prompt('input');switch (data) &#123; case "monday": case "wednesday": case "thursday": case "friday": console.log('wroking'); break; case "saturday": case "sunday": console.log('relaxing'); break;&#125; break ———— 终止循环（只要是循环就可以用，而且要写在循环里面） continue —— 终止本次循环，继续下次循环 typeof 类型转换 数组12var arr = [1, 2, 3, 4, undefined, [], &#123;&#125;];// 里面可以放很多东西 对象12var obj = &#123;lastname: "huang", male: "male", number: 123&#125;// 里面可以放很多东西 编程形式的区别 面向过程（分步骤，能不能做） 面向对象（谁来做） typeoftypeof可以给我们返回6个值 *Number String boolean object undefined function * 两种写法 123typeof('123');typeof '123'typeof(null); // object—— 历史遗留问题 类型转换显式类型转换1234567891011121314151617181920212223242526Number(undefined); // NaNNumber('a'); // NaN/*那些看起来不是数字的，就转不了*/parseInt() // 函数可解析一个字符串，并返回一个整数。相当于Number的小弟/*parseInt(’10‘, 16) ——&gt; 16 16为基底，转化为10进制的数parseInt(string, radix) ---&gt; radio取值范围[2, 32]parseInt(’10abc‘) ————&gt; 返回数值10*/parseFloat(1222.22); // 1222.22 类似parseInt(), 但是只有一个参数，转化为浮点型String(123) // '123' String(mix)转换为字符串类型Boolean(value); /* 转换为布尔类型如果省略 value 参数，或者设置为 0、-0、null、""、false、undefined 或 NaN，则该对象设置为 false。否则设置为 true（即使 value 参数是字符串 "false"）*/toString()var demo = 123;var num = demo.toString(); // undefined 和 NaN 用不了这个方法/*demo.toString(redix); 把123转换为目标进制的数，跟 parseInt(string, radix) 配合用，可以转来转去*/ 隐式类型转换12345678910111213141516171819202122232425262728293031console.log(isNaN(NaN)); // trueconsole.log(isNaN("NaN")); // trueconsole.log(isNaN(abc)); // 报错console.log(isNaN(123)); // falseconsole.log(isNaN("abc")); // true/*为啥会这样子呢？因为调用 isNaN() 的时候会隐式调用 Number("abc"),然后再跟 NaN 比对isNaN(null) ——&gt; Number(null) -&gt; 0 ——&gt; NaN 所以结果是false*/// ++ 、-- 、+/- 、* 、/ 、% 、|| 、&amp;&amp; 、! 、&gt; 、&lt; 、&gt;= 、&lt;= 、== 、!=undefined == null // trueNaN == NaN // falsetypeof (+'abc') // numbertypeof(a); // undefined 未定义的变量在typeof里面不报错typeof(typeof(a)) // "undefined"function myIsNaN(num) &#123; var ret = Number(num); ret += ""; if (ret == "NaN") &#123; return true; &#125;else &#123; return false; &#125;&#125; 例子： 12345678910111213141516171819202122232425var str = false + 1;console.log(str); // 1 var demo = false == 1;console.log(demo); // falseif (typeof(a) &amp;&amp; -true + (+undefined) + "") &#123; console.log("基础扎实"); /* typeof(a) == "undefined" -true == -1 +undefined == NaN */&#125;if (11 + "11" * 2 == 33) &#123; console.log("基础扎实") /* "11" * 2 == 22, "11" - 2 == 9, "10" / 2 == 5, "11" + 2 = "112" "11" % 2 == 1, +"11" + 2 = 13 */&#125;!!" " + !!"" - !!false || console.log('能打印，猪都能上树');// true + false - false == 1 不发生类型转换的=== 、!==]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js简介</tag>
        <tag>变量声明</tag>
        <tag>浏览器内核</tag>
        <tag>堆栈数据</tag>
        <tag>if语句</tag>
        <tag>for循环</tag>
        <tag>运算符</tag>
        <tag>类型转换</tag>
      </tags>
  </entry>
</search>
